---
title: 数据结构--1线性表
date: 2018-01-04 09:21:15
categories: 嵌入式
tags: [嵌入式,学习笔记,线性表]
comments: true

---
>从本篇开始，分四篇总结数据结构和算法的相关内容。数据结构方面，主要总结线性表的顺序存储和链式存储，应重点掌握。栈和队列是两种特殊的线性表，理解其特殊性。树和图目前只做简单了解，后续有需求再做深入研究。存储方式中的索引存储和散列存储仅作了解。算法方面，这里并不展开分析，只总结面试中常出现的查找算法和排序算法。<!-- more -->

# 数据结构的基本概念
## 定义
- 数据结构是研究非数值性程序设计中计算机操作的对象（数据）及其相互关系和运算的学科。
- 更详细的解释为：按照某种逻辑关系组织起来的一批数据，应用计算机语言，按照一定的存取方式将其存储到存储器中，并为这些数据定义运算集合。

## 数据结构的三个方面
当谈到数据结构时，我们主要关心它的三个方面：逻辑结构、存储结构和运算。后面具体分析的某种数据结构也按照该思路展开。

**逻辑结构**

- 数据之间的相互关系。
- 按照每个元素可能具有的直接前驱数和直接后继数分类，可以分为**线性结构和非线性结构**。
- 线性结构又包括线性表、栈、队列等。非线性结构包括树、图等。
- 线性结构中的元素是一对一的关系，树形结构中的元素是一对多的关系，图状结构中的元素是多对多的关系。

**存储结构**

- 逻辑结构在计算机中具体的实现方法。
- 分为**顺序存储、链式存储**、索引存储、散列存储等。
- 顺序存储：把数据存放在地址连续的存储单元里，数据间的逻辑关系和存储关系是一致的。
- 链式存储：借助元素在存储器中的指针表示元素间的逻辑关系，可以存放于连续的空间，也可以存放于不连续的空间。
- 索引存储：在存储数据的同时还存储一张索引表，通过索引表中的索引项定位结点，可以提高查询速度。
- 散列存储：根据元素的特殊字段（关键字key）计算数据元素的存放地址，数据元素按地址存放，可以提高查询效率。

*参考文档：[数据的四种基本存储方法][1]*

**数据运算**

- 对数据的操作。
- 包括增、删、改、查、排序、合并等。

## 顺序存储和链式存储的对比
- 顺序存储
	- 优点：存储密度高；按元素序号随机存取。
	- 缺点：插入、删除的时间复杂度差；需要预先分配存储空间。
- 链式存储
	- 优点：插入、删除方便；动态申请空间。
	- 缺点：存储密度低，需要额外为指针分配空间；只能顺序存取。
- 选择时的考虑
	- 算法设计的要求通常是时间效率高、存储量低。
	- 是否能预先确定存储空间的大小，能则使用顺序存储，否则使用链式存储。
	- 频繁进行何种运算，多查询则使用顺序存储，多插入删除则使用链式存储。

*注：因为顺序存储是用数组实现，因此也有数组和链表对比的提法，内容见上。另外，数组是在栈上，而链表是在堆上，因此其区别也涉及内存中堆和栈的区别。*

*参考文档：[顺序存储结构与链式存储结构的比较][2]*

# 线性表
线性表是包含若干数据元素的线性序列。

**特征**

- 对于表头，无前驱。
- 对于表尾，无后继。
- 其他每个元素有且仅有一个直接前驱和一个直接后继。

## 逻辑结构
见图，是一种线性结构。
![ ](http://osjn6k0nm.bkt.clouddn.com/%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84.png  "线性表的逻辑结构")

## 存储结构
### 顺序存储
线性表的顺序存储结构，用一维数组表示。如图所示。

![ ](http://osjn6k0nm.bkt.clouddn.com/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.png  "顺序表")

#### 结构体表示
顺序存储的实现结构体如下：
```
#define N 100 //定义顺序表的最大长度
typedef int data_t; //定义存储数据的类型，可以替换为其他,如结构体
typedef struct{
	data_t data[N]; //顺序表的存储空间
	int last;//当前表尾下标
}seqlist,*seqlist_t;//顺序表类型
```

#### 数据运算
顺序存储结构的线性表的基本数据运算有：

- 建立空的顺序表
- 清空顺序表
- 销毁顺序表
- 判断顺序表是否空
- 判断顺序表是否满
- 求顺序表长度
- 将数据插入顺序表某一位置
- 删除顺序表某一位置的数据
- 查询顺序表中某一位置上的数据
- 查询顺序表中某一数据的位置
- 修改顺序表中某一位置上的数据
- 修改顺序表中某一数据
- 顺序表的遍历

说明：

1. 表尾下标从-1开始，当有元素插入时，下标加1，正好和数据下标对应。
2. 销毁顺序表时，在函数内置指针为NULL，并不能影响函数外的实参，指针还可以访问堆上的内容，因此需要在函数外置NULL。
3. 顺序表的插入和删除操作，需要大片移动数据。
4. 顺序表的查找是按下标随机查找。
5. 函数传参为指针，函数内改变指针的值，函数外并不会有改变，属于按值传参。比如在函数内头指针位置的改变不会影响主函数中头指针的值。
6. 其余操作均是在此基础上变化，比如合并、拆分、复制、排序等。

### 链式存储
线性表的链式存储，即通常说的链表。链表的结构是动态的，通过结点的指针域确定结点间的关系。结点和链表结构如图所示。其中结点包括data域，存放数据元素,还包括next域，它是一个指针，指向该元素的直接后继所在的结点位置。

![ ](http://osjn6k0nm.bkt.clouddn.com/%E5%8D%95%E5%90%91%E4%B8%8D%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png  "链表")

#### 结构体表示
链式存储的实现结构体如下：
```
typedef int data_t;
typedef struct node{
	data_t data;//结点的数据域
	struct node *next;//结点的后继指针域
}linknode,*linknode_t;
```
#### 数据运算
链式存储结构的线性表的基本数据运算有：

- 创建空的链表
- 清空链表
- 销毁链表
- 判断链表是否空
- 求链表长度
- 头插
- 头删
- 查询链表中某个元素
- 修改链表中某个元素
- 链表的遍历
- 将数据插入链表某一位置
- 删除链表中的某个元素
- 链表倒置

说明：

1. 链表的结构是动态生成的，不需要判断是否满。
2. 清空链表和清空顺序表不一样，不能使用h->next=NULL,因为链表中的结点均为动态申请，因此需要挨个释放空间，即删除。
3. 销毁链表则需先清空链表，再释放头结点。
4. 链表的头结点比较好操作，因此常使用头插法和头删法。
5. 链表中结点有一个指针域，因此操作中涉及指针的连接、断开等问题，可使用画图辅助理解。
6. 链表倒置最好的思路：挨个指向数据，使用头插法的思路调整指针指向即可。无需malloc和free函数。

#### 单向循环链表
以上所述链表为单向不循环链表，简称为单链表。将单链表首尾相连，就构成了单向循环链表，如图所示。单向循环链表可以使得从链表当中一个结点出发，访问到链表的全部结点。

![ ](http://osjn6k0nm.bkt.clouddn.com/%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.jpg  "单向循环链表")

单向循环链表的运算和单链表比较：

1. 创建空链表时，填充头结点的指针域为h->next=h。
2. 判断链表是否为空：h->next==h。
3. 插入与删除和单链表操作一样。
4. 判断指针是否到达表尾：p->next==h。
5. 对于在表尾频繁操作时，可以求得表尾指针，再进行操作，而不必使用头指针遍历到表尾。例如用尾指针实现两个单向循环链表的连接。

#### 双向不循环链表
单链表存在两个问题：

1. 在查找直接前驱时时间复杂度依赖于链表的长度，耗时较多。
2. 如果其中有一个指针被破坏，则整个链表脱节。

因此引入双向不循环链表，其结构如图所示。双向是指增加一个指针指向直接前驱。双向链表是以空间换时间的思想，解决单链表存在的问题。

![ ](http://osjn6k0nm.bkt.clouddn.com/%E5%8F%8C%E5%90%91%E4%B8%8D%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png  "双向不循环链表")

其实现的结构体为：
```
typedef int data_t;
typedef struct dnode{
	data_t data;
	struct dnode *prior,*next;
}dlinknode,*dlinknode_t;

对称性：
(p->prior)->next=p=(p->next)->prior
```

双向不循环链表的运算和单链表比较：

1. 创建空链表时，多一个指针。
2. 求链表长度、查找元素、获取元素位置等和单链表一样。
3. 查找或者访问链表元素，可以正向也可以反向。
4. 将数据插入链表某一位置时，需要处理四个指针。
5. 删除链表中的某个元素时，需要处理两个指针。

说明：

1. 改变指针关系时，要注意先后顺序，如果写反了，可能就不能操作了，比如丢失了某个指针。解决思路：先连上新增的，这样原来的指针可以使用。然后再断开需要断开的指针。如果先删除需要删除的指针，那么可能需要新连接的指针就不知道连到哪里。
2. 以上介绍了单向循环链表和双向不循环链表。其中循环是指链表首尾相连，双向是指一个指针指向后继，一个指针指向前驱。因此，根据这两个特征，可以组合为四种形式的链表。使用场合应根据各自的特点来区分。其异同点如图所示。
3. 例如Linux内核中的链表。头文件为include/linux/list.h。其中有一个list_head结构体。list_head有两个指针，一个是next,一个是prev，通常组织为双向循环链表。注意：在linux内核链表中，**不会在链表结构中包含数据，而是在数据结构中包含链表**。因为链表数据类型差别很大，如果在每一个链表结构中定义数据类型，则不利于抽象为公共模板。
![ ](http://osjn6k0nm.bkt.clouddn.com/%E5%90%84%E7%A7%8D%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83.jpg  "各种链表的比较")

## 实例分析
### 员工信息系统的增删改查
- 员工信息系统涉及每个员工的许多信息，因此通常用结构体表示，即数据是构造数据类型。
- 考虑到总体员工数量不确定，可以采用链式存储结构，而非顺序存储结构。
- 员工信息的结构体可以表示为方式一，包含指向下一个结点的指针。那么增删改查函数需要根据实际需求编写。
- 也可以采用方式二，员工信息的结构体单独定义，链表结构体单独定义，那么增删改查可以使用模板函数，获得结构体或者结构体指针后，再进一步访问结构体成员。

结构体表示：
```
方式一：
struct node{
	int id;
	char name[10];
	int age;
	bool sex;
	float salary;
	struct node *next;
};

方式二：
typedef struct staff{
	int id;
	char name[10];
	int age;
	bool sex;
	float salary;
}staff,*staff_t;

typedef staff_t datatype;
//或者typedef staff datatype;

struct node{
	datatype data;
	struct node *next;
};
```

*参考文档：[C语言中怎样用链表保存结构体数据（动态数据结构）][3]*

### 视频诊断项目中顺序表的使用
- 视频诊断项目其中一个需求是诊断摄像头的网络通断情况。采用的思路是：保存一份网络内正常情况下所有摄像头IP的顺序表La，实时的按一定频率扫描网络，得到实时扫描到的IP顺序表Lb,对La、Lb两个顺序表进行对比合并等操作，判定摄像头网络故障。
- 主要涉及创建顺序表、插入数据、查找数据、顺序表遍历、两顺序表合并等操作。
- 注意这里入表的数据类型为char *型，因此查找操作不能使用“=”运算符判断是否找到，而需使用strcmp函数。
- 由于项目中使用顺序表是为了比较多个IP字符串，因此需要按照功能封装函数，函数内可能包含了顺序表的操作。此时需要注意，如果形参为顺序表指针，那么在函数内使用顺序表指针进行操作后，并不会影响函数外的顺序表指针。解决方案是：**要么函数返回值返回顺序表指针，要么形参传递顺序表指针的地址**。
- 如下的代码，运行时将在main.c出现段错误，原因即是在函数内的La的值并不会影响main.c中La的值，所以再通过La访问数据时，由于La=NULL，所以出现段错误。

```
info_management.c
int cameraIP_enter_sqlist(sqlist * La,uint8_t (*IPlist)[16],int count)
{
	int i;
	
	if((La = list_create()) == NULL)
	{
		printf("fail to create list La\n");
		return -1;
	}
    		
	for(i=0;i<count;i++)
	{
		list_insert(La,IPlist[i]);
		
	}
    	
	list_show(La);
	return 0;
	
}

main.c
int main(int argc,char *argv[])
{
	……
	cameraIP_enter_sqlist(La,IPlist,camera_num);

	for(i=0;i<=La->last;i++)	
	{
		if(strcmp(La->data[i],localIP)!=0)
		{
			strcat(scan_target,La->data[i]);
			strcat(scan_target," ");
		}
	}

}
```
### 仓储物联项目中链表的使用
- 该项目是由FS4412、M0(NXP LPC11C14)、PC等组成的系统，各自的作用是PC为核心服务器端，FS4412为前端数据中心，M0为远程监控终端。
- 主要是实现M0采集环境参数，物品参数，通过zigbee网络将信息发送给FS4412，同时在FS4412上构建嵌入式web服务器，使用户在PC机上对环境信息货物信息进行监控。
- 这是一个多线程的项目，涉及数据库线程、接收M0数据线程、M0数据分析线程、M0控制命令发送线程、短信模块控制线程、蜂鸣器控制线程、摄像头控制线程、处理消息队列请求线程、更新共享内存实时数据线程等。具体在多线程一节和项目实践分析中详细叙述。
- 其中很多地方使用了数据结构。比如：数据库线程中，创建一个用于存储对数据库操作（增删改查）的链表。在while(1)循环中判断链表是否为空，如果空则跳出，如果不为空，则取出链表头的内容进行解析，完成相应的数据库操作并释放结点，如此循环。接收M0数据线程中，从ttyUSB0设备结点中读取数据，判断包头是否正确，判断是货物还是环境信息，并插入数据缓存链表中。M0数据分析线程中，从数据缓存链表中取表头数据，如果是环境信息，将数据加入到数据库链表中，并激活更新共享内存实时数据线程。如果是货物信息，也将其加入到数据库链表中。
- 相关源代码详见[gist][11]。

### 开源项目中的数据结构使用
**mosquitto源码**
对某一个topic的所有订阅者被组织成一个双向链表。每一个结点保存一个订阅者。实现结构体如下：
```
struct _mosquitto_subleaf {
	struct _mosquitto_subleaf *prev;
	struct _mosquitto_subleaf *next;
	struct mosquitto *context;
	int qos;
};
```

用于保存订阅树的结点，包括叶子结点和中间结点。采用孩子-兄弟链表法进行存储。实现结构体如下：
```
struct _mosquitto_subhier {
	struct _mosquitto_subhier *parent;
	struct _mosquitto_subhier *children;
	struct _mosquitto_subhier *next;
	struct _mosquitto_subleaf *subs;
	char *topic;
	struct mosquitto_msg_store *retained;
};
```
*参考文档：*
*[mosquitto 源码分析 （二）订阅树的搭建][7]*
*[mosquitto 源码分析 （一）核心数据结构][8]*

**cJSON源码**
cJSON结构体是一个双向链表。对节点的操作包括增删改查等。实现结构体如下：
```
/* The cJSON structure: */
typedef struct cJSON
{
    /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem */
    struct cJSON *next;
    struct cJSON *prev;
    /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. */
    struct cJSON *child;

    /* The type of the item, as above. */
    int type;

    /* The item's string, if type==cJSON_String  and type == cJSON_Raw */
    char *valuestring;
    /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */
    int valueint;
    /* The item's number, if type==cJSON_Number */
    double valuedouble;

    /* The item's name string, if this item is the child of, or is in the list of subitems of an object. */
    char *string;
} cJSON;
```
*参考文档：*
*[cJSON源码分析][9]*
*[cJSON源码分析][10]*

注：关于开源项目源码阅读另作专题讨论。一般的开源项目中都有一些数据结构的使用，比如另外在paho.mqtt.c源码中有链表、树、堆等数据结构的使用，有需要时可以做深入分析。

### 面试相关问题
1. 链表的倒序打印
	- 除了上面提到的方法，还可以使用递归逆序打印，或者每个元素依次入栈再依次出栈。
	- 递归的方法可以很好的保留现场，本质是一个栈，利用这个特征可以解决一些问题。例如在图的深度优先搜索算法也是用了递归，在回溯过程能够方便的获取某个结点的其他邻接点。
2. 查找单向链表中倒数第k个结点
	- 首先想到的思路是遍历第一遍，确定链表长度N。遍历第二遍，指针移动到N-k+1的位置取得数据。
	- 改进的思路是只遍历一遍完成，先使用一个指针移动到K-1位置，然后再使用另一指针指向头结点，此时两个指针同时向后移动，当第一个指针到达尾部，第二个指针恰好到达N-K+1位置，即倒数第K个。
3. 确定单向链表是否有环
	- 首先想到的思路是取每一个结点，再取其他所有结点的next指针与之对比是否相等，如果没有则跳到下一个结点，再和所有其他结点对比，以此类推，时间复杂度高。
	- 改进的思路是设计两个指针，快指针每次移动两个位置，慢指针每次移动一个位置，如果有环，则某时刻两个指针相等，如果没有环，则快指针先到达表尾。
4. 约瑟夫环问题
	- 问题描述为一个圆环，包括n个数，每次第m个数出列，之后的数重新从1开始计数，问最后一个出列的数是什么。
	- 使用循环链表实现，指针移动到第m个数时，删除该节点，再重新开始计数，依次删除，直到只剩下最后一个数据，打印该数据。

*参考文档：*
*[关于数据结构的10个面试题(c语言实现)][4]*
*[面试常备题---链表总结篇][5]*
*[如何判断链表中是否有环][6]*

# 个人观点
- 数据结构在嵌入式系统开发中，应该**作为一种工具使用**，而无需花过多精力探讨其内部实现。因此需熟练掌握其实现原理，主要理解其存储方式即结构体表达，和基本的运算即增删改查等。在此基础上，可以形成各种数据结构基本运算的代码模板，在实际项目中直接使用即可。此外，链表、栈、队列等在实际项目和面试中经常出现，其使用方法应熟练掌握。
- 数据结构的编程是C语言高级编程的综合应用，包括：指针的操作、结构体的操作、动态内存分配的操作等，相当于是前面知识的实践应用，所以可以综合前面知识总结的内容进行分析。

[1]: http://student.zjzk.cn/course_ware/data_structure/web/gailun/gailun1.1.2.htm
[2]: https://www.cnblogs.com/super-d2/archive/2012/08/10/2632064.html
[3]: https://zhidao.baidu.com/question/277301839.html
[4]: http://blog.csdn.net/lcl_data/article/details/5513517
[5]: https://www.cnblogs.com/wenjiang/p/3310233.html
[6]: http://blog.csdn.net/thefutureisour/article/details/8174313
[7]: http://www.360doc.com/content/14/1009/17/12928831_415569940.shtml
[8]: http://blog.csdn.net/sinat_31500569/article/details/64200902
[9]: https://www.jianshu.com/p/7bdb79bdb8aa
[10]: http://www.codexiu.cn/javascript/blog/21746/
[11]: https://gist.github.com/youxiaobo/fa52068bf23c0a2def41e508d2a4ab22