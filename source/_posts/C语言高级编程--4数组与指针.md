---
title: C语言高级编程--4数组与指针
date: 2017-11-26 09:21:15
categories: 嵌入式
tags: [嵌入式,学习笔记,数组,指针]
comments: true

---
> 本篇文章主要介绍了数组和指针相关的知识点，并分析了二者之间的联系和区别。此外还介绍了一些特殊情况：空指针、void 指针、const修饰指针。最后针对实践中常用的字符串，总结了其使用的注意事项。<!-- more -->

# 数组
## 数组基础
**数组的特点**

1. 数组元素类型一样。
2. 存储空间连续。区别于链表。
3. 数组名是数组的起始位置，是地址常量。

**注意事项**

1. 对数组名求sizeof，结果是整个数组的占用总空间，数组个数=sizeof(数组名)/sizeof(数据类型)。
2. 数组名是地址常量，则说明不能对其做自增自减，改变其值。
3. 数组元素的数据类型可以是基本类型也可以是构造类型。因此有字符数组、指针数组、结构体数组等，后续相关部分有详细介绍。
4. 方括号中的常量表达式在定义就必须确定，而不能随着程序运行而改变。

## 数组定义、初始化、引用
**定义**
```
<存储类型>  <数据类型>  <数组名>[数组元素个数]
```

**初始化**

1. 全部元素初始化时，方括号中个数可省略不写。
2. 数组全部初始化为0的几种方法：
```
int a[10]={0};
int a[10];memset(a,0,sizeof(a));
int a[10];bzero(a,sizeof(a));
```

**引用**
```
<数组名>[下标]
```
说明：

1. 数组必须逐个元素引用，不能整体引用。所以在定义完毕后如果需要赋值，必须一个一个赋值，可以使用for循环。而不能写int a\[3\];a\[3\] = {1,2,3};
2. 注意数组下标越界，相当于内存访问越界，造成的结果无法估量。不确定会产生什么后果，这取决于越界访问的内存空间是否是空闲以及访问是读还是写。

## 二维数组
- 二维数组的定义、引用、初始化类似于一维数组。
- 二维数组的存储是按行优先顺序存储的，也是存储在连续的空间。
- 初始化时可以省略第一个方括号中的数字。
- 对于二维数组元素或者元素地址的各种变形，要从本质上理解其含义，以a\[2\]\[3\]为例：
	- a是二维数组名，是地址常量。a+1表示移动一行。a+1表示第二行的地址。
	- a\[0\]、a\[1\]等是一维数组名，也是地址常量。a[0]+1表示移动一列，a[0]+1表示第一行第二列的地址，即&a\[0\]\[1\]。

# 指针
## 指针基础
**基本概念**

- 在计算机中，所有的数据都存放在存储器中，将存储器中的一个字节称为一个内存单元，不同的数据类型占有不同的内存单元数量。比如整型占4个内存单元(即4个字节)。
- 为了正确的访问内存单元,必须为每个内存单元编号,根据每个内存单元的编号就可以找到该内存单元。内存单元的编号也叫地址,而又称这个地址为指针。
- 内存单元的指针(地址)和内存单元的内容（具体存放的变量）是两个不同的概念。指针指向的内存区域的数据称为指针的目标，如果指向的区域是一个变量的内存空间，则这个变量称为指针的目标变量。

**使用指针的好处**

1. 使程序简洁、紧凑、高效。
2. 有效地表示复杂的数据结构。
3. 实现动态分配内存。
4. 得到多于一个函数返回值。

**注意事项**

1. 理清各个概念的本质。是变量还是常量，是指针还是数据，指针是变量还是常量，所指向的目标是变量还是常量。
2. 实践中建议画图标明指向关系。在程序出错时，也要从本质上分析原因。

使用示例：
```
px		表示指针变量，内容是地址变量。
*px		表示指针指向的目标，内容是数据。
&px		表示指针变量占用存储区域的地址，内容是地址常量。
```

## 指针定义、初始化、引用
**定义**
```
<存储类型> <数据类型> *<指针变量名>
```
说明：

1. 定义时，将星号写在靠近变量名的一侧，而不是靠近数据类型。
2. 这里的数据类型是指指针指向的目标的数据类型。

**初始化**
```
<数据类型> *<指针变量名>=<地址量>
int *p = &m;
或者
int m,*p;
p=&m;
```
说明：
未经赋值的指针变量不能随便使用。例如：int \*p;\*p=50;这是错误的，没有对指针进行初始化，指针随机指向一个内存单元，这样的指针成为野指针，代码在执行时会出现segmentation fault，访问了一个非法地址。在对指针变量进行间接引用前必须确保它们已经指向了一个合法的对象。

**引用**

1. 对指针的引用使用\*。\*叫做指针运算符或者叫间接存取运算符。通过指针访问它所指向的对象叫做变量的间接访问。
2. &是取地址运算符，和*互为逆运算。

注意：
将一个变量的地址赋值给指针，那就意味着指针所指向的内存单元就是存储该变量的内存单元。无论是改变指针所指向的内存单元的内容还是直接改变变量的值，都会相同的效果。

使用示例：
```
int a,*p;
a = 1;
p = &a;
*p=2;
```
该例中a的值也会有变化，这是通过指针改变了变量的值。因此才会有如果不希望通过指针改变变量的值，那么使用const修饰。

## 指针运算
指针的运算是指以指针变量所存放的值作为运算量而进行的运算。指针的运算就是地址的运算。

- 算术运算
	- +、\-、++、\-\-，表示移动一个或多个单位长度，单位长度是指数据类型所占字节数。因此其值的改变为数据类型所占字节大小乘以1或n。
	- 两指针相减：结果为一个整数，而不是地址量，表示两指针相隔的数据个数。
- 关系运算：比较少用。多用if(px != NULL)和空指针进行比较。或者两个指针一起向中间移动时，会比较两个指针。
- 赋值运算
 	- 对指针赋值使用&，和\*互为逆运算。多个运算符在一起要注意优先级。
 	- \*p++ 表示\*(p++)，表达式的值是取原p指向的对象值，然后p移动一个位置。 
 	- \*++p 表示\*(++p)，表达式的值是p移动一个位置后，再取其指向的对象值。
- sizeof运算符：sizeof(px)，任何类型的指针变量求sizeof，大小始终是4或者8字节，是由计算机系统位数决定，和类型无关。

## 二级指针
- 二级指针是即指向一级指针变量的指针变量，即指针指向的目标是指针。
- 定义：<存储类型> <数据类型> **<指针名>
- 二级指针的运算，和一级指针类似，理解本质即可。++，\-\-也是移动单位长度，这里的单位长度是指针类型的长度，则是4字节或者8字节。另外，用sizeof对二级指针运算，同样是4字节或者8字节。

使用示例：
```
e.g1:字符指针数组名赋值给字符二级指针
char *p[5]={"beijing","tianjin","shanghai","sichuan","liaoning"};
char **pp=p;

e.g2:指针数组名赋值给二级指针
int a[2][3];
int *p[2];
p[0]=a;
p[1]=a+1;
int **q = p;
```
## 特殊指针
### 空指针
- 空指针是指指针变量为0的指针，表示为NULL。表示目前**尚未指向任何对象。**
- 用处：(1)在需要返回指针时，如果失败常常返回NULL。(2)在指针定义时，常常初始化为NULL。
- 修改0地址的值或者进行间接引用操作都是不允许的，会出现段错误。
- 如果指针初始化为NULL，后又访问或者修改该地址的内容，则一定会出现段错误，所以可以分析出原因：是由于指针指向的对象不明确造成的。
- 一般在对指针进行引用前，应该先判断指针是否为空。

### void指针
- void指针是指向不明确数据类型的指针变量。这是空类型指针，区别空指针概念。
- 不确定数据类型表示只知道目标的起始位置，但是不知道目标的大小，即占用字节数。
- void指针可以指向任何类型的数据，那么任何类型的指针可以赋值给void指针，不需要强制类型转换。但是反过来，void指针赋值给某一具体类型的指针变量，则需要强制类型转换。
- 在引用void指针的目标值时，需要进行强制类型转换。
- void指针的运算，ANSI C和GUN C规定不一样。ANSI C规定不允许对void指针进行运算，而GUN C可以。
- 使用场合：使用任意类型的指针的场合，比如函数参数传递，函数返回值。例如作为一种函数模板，适用于多种情况。
- 扩展知识：void也是一种数据类型，空类型。void不能定义变量。void的作用是(1)对函数返回做限定。(2)对函数参数做限定。

使用示例：
```
e.g1:给某个指针动态分配内存，malloc需要强制类型转换
void *malloc(size_t size);
int *p;
p = (int *)malloc(sizeof(int)*n);

e.g2:内存拷贝函数，任何类型的指针都可以使用。也符合内存拷贝的本质，与类型无关。
void *memcpy(void *dest, const void *src, size_t n);
char a1[5]={0};
char b1[]={"hi"};
memcpy(a1,b1,sizeof(b1));
```

*参考文档：*
*[void指针详解][1]*
*[void及void指针含义的深刻解析][2]*
*[void指针用法][3]*

### const修饰指针
- const int *a：常量化指针指向的对象，不予许通过指针修改指向的对象，但可以直接修改变量。
- int * const a：常量化指针变量，只能指向同一个对象，指针变量的值不能改变，但是可以通过指针改变对象的值。
- const int * const a：常量化指针变量和目标表达式，既不能通过指针修改指针所指向的变量的值，也不能修改指针变量的地址。

注意：

1. 强行修改会报错：assignment of read-only location ……
2. const声明的变量必须在初始化时赋值，后面再赋值，则会报错。

使用示例：
```
e.g1:
char *strcpy(char *dest, const char *src);
这里加const是为了不予许在函数内，通过*src修改原字符串的内容。

e.g2:
int main(int argc,const char *argv[])
这里的形参char *argv[]可以理解为char **argv。const限制*argv[]不能变，即不能通过指针改变字符串。而argv[1]和argv都是可变的。
```
*参考文档：*
*[读懂C语言const限定以及复杂定义][4]*
*[C语言中strcpy字符串复制库函数的理解与分析][5]*

# 指针与数组
由上面内容可知，指针和数组有很多相似之处。要从本质上理解区分指针和数组。在C语言中指针的效率往往高于数组下标。编译器对程序中数组下标操作会全部转换为对指针的偏移量操作。
## 数组指针
数组指针是指向数组起始位置的指针，本质是指针。实践中多指指向二维数组的指针。
### 指针与一维数组
- 数组在内存中的位置在运行过程中不能动态改变。数组名不允许被赋值。
- 数组的指针是地址常量，而指针变量是地址变量。
- *运算符称之为指针解引用，即根据地址获取地址里的内容。[]运算符称之为下标运算，表示指针移动n个单位长度后取内容。

使用示例：
```
int a[5];
int *p = a;
则有
数组元素表示：*(p+i)<=>p[i]<=>a[i]<=>*(a+i)
数组元素地址表示：p+i<=>&p[i]<=>&a[i]<=>a+i
```

### 指针与二维数组
访问二维数组元素的方法有：

1. 列指针（一级指针），利用顺序存储的特点访问。
2. 行指针。
定义：存储行地址的指针称为行地址。加1表示移动一行。
格式：<存储类型> <数据类型> (*<指针变量名>)[表达式]
注意：方括号的表达式表示指针加1，移动几个数据，用行指针操作二维数组时，代表一行的个数，即列数。
3. 一级指针数组。
定义指针数组操作二维数组时，指针数组的个数应该为二维数组的行数。
4. 二级指针。注意：二级指针的初始化在这里必须赋值为指针数组名，而不是二维数组名，否则不知道如何偏移。

使用示例：
```
	int a[2][3]={{1,2,3},{4,5,6}};
	//访问二维数组元素
	//数组方式
	//a[1][2];
	printf("%d %d %d\n",a[1][2],*(a[1]+2),*(*(a+1)+2));

	//列指针访问
	int num = sizeof(a)/sizeof(int);
	int row = sizeof(a)/sizeof(a[0]);
	int col = num / row;
	int *pcol = &a[0][0];
	printf("%d\n",*(pcol+1*col+2));

	//行指针访问
	int (*prow)[3];
	prow = a;
	printf("%d\n",*(*(prow+1)+2));

	//指针数组访问
	int *parray[2];
	parray[0] = a[0];
	parray[1] = a[1];
	printf("%d\n",*(parray[1]+2));

	//二级指针访问
	int **psec;
	//psec =a;//对二级指针赋值，是指针数组名，而不是二维数组名，否则psec+1不知道如何偏移
	psec = parray;
	printf("%d\n",*(*(psec+1)+2));

	//访问二维数组元素的地址
	printf("%p %p %p\n",&a[1][2],a[1]+2,*(a+1)+2);
	printf("%p %p %p %p\n",pcol+1*col+2,*(prow+1)+2,parray[1]+2,*(psec+1)+2);
```

注意：
a[i]和*(a+i)是完全等价的，不管a是数组名还是指针，因此示例中可以按照此规则等价转换书写更多的形式。

## 指针数组
指针数组：本质数组，数组名相当于多级指针。指针数组的数组名是数组的起始地址。

使用示例：
```
	e.g1:
	访问二维数组
	int a[2][3]={{1,2,3},{4,5,6}};
	int *parray[2];
	parray[0] = a[0];
	parray[1] = a[1];

	e.g2:
	字符指针数组
	int main(int argc,const char *argv[])
	这里是指针数组做形参，相当于同级别的指针。

	char *fruit[3]={"apple","pear","grape"};
```

# 字符串、字符数组、字符指针
关于字符串的使用，涉及字符数组和字符指针。数组和指针前面已经介绍，数组和指针使用的注意事项，字符数组和字符指针同样应注意。除此之外，重点理解字符串的特殊之处即可。
## 字符串
**定义**
字符串是由'\0'作为结束符的一组字符，用字符数组表示。

**字符串常量**
在程序中使用字符串常量会生成一个“指向字符串的常指针”。当一个字符串常量出现在一个表达式中，表达式所引用的值是存储该字符串常量的内存首地址，而不是字符串本身。

**字符串处理函数**
字符处理函数常用的有strlen、strcpy、strcmp、strcat、strtok。以及带有长度限制的对应函数，例如strncpy等。这些函数需要熟练使用，这在Linux应用程序开发中有使用。
说明：

1. 每一个函数的具体用法参见man手册。一定要理解各个函数的含义，尤其是特殊处理。
2.  strlen统计字符长度，不带'\0'。
3.  strcpy不会做越界检查，需自己保证长度合适。而strncpy不保证最后一个字符是'\0'。
4. strtok功能是分割字符串，会破坏原有字符串完整性，如果要想保持不变，使用strchr和sscanf组合代替。

*参考文档:*
*[C语言字符串使用注意事项][6]*
*[常见字符串处理函数梳理及分析 ][7]*
*[C语言字符串操作总结大全(超详细)][8]*
*[C语言中strcpy字符串复制库函数的理解与分析][5]*

## 字符数组
- 字符数组是有一定顺序关系的若干字符变量的集合。可以是一维的也可以是二维的。字符数组具有普通数组的性质，又有其特殊性。
- 初始化：可以使用逐个赋值，也可以使用字符串常量。

```
char str[6]={'h','e','l','l','o','\0'};
char str[6]="hello";
char str[]="hello";
char fruit[][7]={"apple","orange","grape"};
```

注意：

1. 用字符串赋值比用字符逐个赋值多一个字符，所以通常用字符串赋初值时，不写数组长度。
2. 如果希望字符数组表示字符串，那么字符逐个赋值时，应该额外在最后手动添加'\0'。即a[strlen(s)]='\0'。
3. 字符数组一定不能越界访问。如果定义了数组长度N，输入时只能输入N-1个字符。
4. 字符数组名同样也是地址常量，不能自增自减改变其值。

## 字符指针
- 字符指针就是指向字符类型对象的指针。如果字符指针指向字符串，则存储字符串的起始地址，即指针指向字符串的第一个字符。
- 初始化：可以赋值为字符数组名，也可以使用字符串常量。

```
char str[]="hello";char *p = str;
char *p="welcome";
```

注意：

1. 初始化字符指针是把内存中字符串的首地址赋予指针，并不是把字符串复制到指针中。而字符串本身存储在内存的其他地方。
2. char \*p="welcome";相当于const char \*p="welcome";因此按照const修饰指针的规则，则不能通过指针修改字符串的内容，会引起段错误。但是指针本身可以改变，p++是允许的。
3. 字符指针作为形参，函数内判断字符串是否达到结尾，通常使用while(*s == '\0')，而不用其长度判断。
4. 获得字符串长度，通常使用strlen，而不能对字符指针求sizeof，因为其代表的是指针占内存空间大小。如果对字符指针求sizeof控制长度，打印时会导致字符串打印不全。
5. 如果给指向字符串的字符指针动态分配空间时，也应该是strlen(s)+1，因为要给'\0'提供一个位置。否则在打印时会导致字符串打印完全后还跟着乱码字符。

*参考文档*
*[C语言字符串指针（指向字符串的指针）][9]*
*[c中给字符数组，字符串指针赋值的方法总结][10]*

## 字符指针数组
- 字符指针数组即是在数组中存储若干个字符串首地址。
- 字符指针数组的数组名是代表数组的起始位置，而数组元素是字符指针，因此数组名是指针的地址，即为二级指针，因此使用二级指针操作。

使用示例：

```
char *p[5]={"beijing","tianjin","shanghai","sichuan","liaoning"};
char **pp=p;//(用二级指针承接指针数组名)
```

# 个人观点
1. 理解每一个概念的本质含义。从本质上去理解每一个知识点的使用方法和注意事项。
2. 当出现多个名词组合在一起时，学会分解，从简单组合到复杂。
3. 对数组和指针的掌握程度是熟练使用。此外建议通过读经典源码，了解通用写法。

[1]: http://blog.csdn.net/zycxnanwang/article/details/52876985
[2]: http://blog.csdn.net/geekcome/article/details/6249151
[3]: http://blog.chinaunix.net/uid-22197900-id-359211.html
[4]: https://www.cnblogs.com/kewei-ma/p/3668227.html
[5]: https://www.cnblogs.com/haore147/p/3646311.html
[6]: http://blog.csdn.net/lhl_blog/article/details/39695457
[7]: http://www.sohu.com/a/162885448_505901
[8]: http://www.jb51.net/article/37410.htm
[9]: http://c.biancheng.net/cpp/html/80.html
[10]: https://www.cnblogs.com/lumanman/p/3297091.html