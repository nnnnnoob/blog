---
title: 数据结构--2栈和队列
date: 2018-01-10 09:21:15
categories: 嵌入式
tags: [嵌入式,学习笔记,栈,队列]
comments: true

---
>本篇介绍了两种特殊的线性表：栈和队列。栈的特点是先进后出，队列的特点是先进先出。同样按照逻辑结构、存储结构、数据运算三个方面展开进行分析。最后还列举了一些栈和队列在实践中的应用。<!-- more -->

# 栈
## 基本概念
- 栈是限制在一端进行插入和删除操作的线性表，也称堆栈。允许操作的一端称为栈顶，固定的一端称为栈底。特点是**先进后出**。
- 同样有两种存储方式，顺序存储和链式存储，其结构如图所示。

![ ](http://osjn6k0nm.bkt.clouddn.com/%E6%A0%88%E7%9A%84%E7%BB%93%E6%9E%84.png  "栈的结构")

## 顺序栈
它是顺序表的一种，具有顺序表同样的存储结构，由一维数组表示，配合数组下标表示栈顶位置top，完成各种操作。

### 结构体表示
顺序栈的实现结构体如下：

```
方式一：
#define N 100 //定义顺序栈的最大长度
typedef int data_t; //定义存储数据的类型，可以替换为其他,如结构体
typedef struct{
	data_t data[N]; //栈的存储空间
	int top;//当前栈顶下标
}seqstack,*seqstack_t;//顺序栈类型

方式二：
typedef int data_t;//定义栈中数据元素的数据类型
typedef struct{
	data_t *data;//用指针指向栈的存储空间
	int maxlen;//栈的最大元素个数
	int top;//栈顶位置
}seqstack,*seqstack_t;//顺序栈类型
```

说明：

1. 顺序栈和线性表的顺序存储结构体一样，只是将last成员改为top成员。下标为0是栈底，下标为last是栈顶。
2. 方式二的写法，未预先指定数组大小，而是定义数据指针和栈的最大大小，在创建栈时指定栈的最大长度，然后malloc出最大长度个空间来存储。

### 数据运算
顺序栈的基本数据运算和顺序表类似，有：

- 创建空的顺序栈：s->top=-1
- 清空顺序栈
- 销毁顺序栈
- 判断顺序栈是否为空
- 判断顺序栈是否为满
- 求顺序栈长
- 入栈：相当于在last+1位置插入
- 出栈：相当于删除last位置元素
- 取栈顶元素：相当于查询last位置的元素

## 链式栈
链式栈即为链式存储的栈。其中插入和删除操作都在链表头进行，链表尾就是栈底，栈顶指针就是头指针。

### 结构体表示
链式栈的实现结构体如下：
```
typedef int data_t;//定义栈中数据元素数据类型
typedef struct node_t{
	data_t data;//数据域
	struct node_t *next;//指针域
}linknode，*linknode_t;//链栈类型定义
```

说明：
链式栈的结构和单向不循环链表的结点结构一样，无需改动。

### 数据运算
链式栈的基本数据运算和链表类似，有：

- 创建空的链式栈
- 清空链式栈
- 销毁链式栈
- 判断链式栈是否为空
- 求链式栈长
- 入栈：相当于头插法
- 出栈：相当于头删法
- 取栈顶元素：相当于查询第一个数据元素

# 队列
## 基本概念
- 队列是限制在两端进行插入和删除操作的线性表，允许在队尾进行插入操作，允许在队头进行删除操作。特点是**先进先出**。
- 同样有两种存储方式，顺序存储和链式存储，其结构如图所示。

![ ](http://osjn6k0nm.bkt.clouddn.com/%E9%98%9F%E5%88%97%E7%9A%84%E7%BB%93%E6%9E%84.png  "队列的结构")

## 顺序队列
它是顺序表的一种，具有顺序表同样的存储结构，由一维数组定义，配合数组下标表示队头位置和队尾位置完成各种操作。

### 结构体表示
顺序队列的实现结构体如下：
```
typedef int data_t;//定义队列数据元素的类型
#define N 64//定义队列的容量
typedef struct{
	data_t data[N];//用数组作为队列的存储空间
	int front,rear;//队头和队尾位置
}sequeue，*sequeue_t; //顺序队列类型定义
```

说明：
顺序队列的结构和线性表顺序存储的结构类似，只是last位置变为front和rear位置。

### 循环队列
- 顺序队列和线性表的顺序存储操作一样，只是在队尾插入（下标为last+1），在队头删除（下标为0）。
- 和线性表一样，如果在队头删除时，后面的元素需要挨个向前移动，因此效率很低。
- 为了解决这个问题，以调整下标位置代替元素移动，不限制队列的元素一定存储在数组的前n个单元。因此删除时，不将后面的元素向前移动，而是将队头向后移动。
- 但是还存在一个问题，插入时在队尾插入，如果满了就不能插入了，但是前面位置还有空闲空间，称为假溢出。
- 因此将队头和队尾相连，构成循环队列。

定义：
队列头尾相接的**顺序存储结构**，称为循环队列。

说明：

1. 如果将队头和队尾相连，那么队列满和队列空都是front==rear。为了区分队列满和队列空，因此满队元素个数比数组元素个数少一个。
2. 因此有两种方式：(a)front指向队头元素的前一个位置，rear指向队尾元素所在位置。(b)front指向队头元素的位置，rear指向队尾元素的下一个位置。

### 数据运算
循环队列的基本数据运算和顺序表类似，有：

- 创建空的循环队列：sq->front=sq->rear=0
- 清空循环队列
- 销毁循环队列
- 判断循环队列是否空：sq->front==sq->rear
- 判断循环队列是否满：(sq->rear+1)%N=sq->front
- 求循环队列长度：(sq->rear-sq->front+N)%N
- 入队：队尾下标移动，sq->rear=(sq->rear+1)%N
- 出队：队头下标移动，sq->front=(sq->front+1)%N

## 链式队列
链式队列即为链式存储的队列。队头指针指向头结点，队尾指针指向最后一个结点。

### 结构体表示
链式队列的实现结构体如下：

```
typedef int data_t; //定义链队列中数据元素的数据类型
typedef struct node{
	data_t data;//结点数据域
	struct node *next;//结点指针域
}linknode,*linknode_t;//结点类型定义

typedef struct{
	linknode_t front,rear;//链队列指针
}linkqueue,*linkqueue_t;//链队列类型定义
```

说明：

1. 链式队列的结点结构和单向不循环链表的结点结构一样，无需改动。
2. 链式队列还需要用两个指针来定义。其中front指针相当于单向不循环链表的头指针，相比之下，多了一个队尾指针。

### 数据运算
链式队列的基本数据运算和链表类似，有：

- 创建空的链式队列：需要先申请结点空间，再申请队列指针的空间。
- 清空链式队列：挨个数据出队。
- 销毁链式队列：先清空队列，置front、rear指针为NULL，再释放队列指针。
- 判断链式队列是否空
- 求链式队列长度
- 入队：在队尾插入，使用rear指针操作。
- 出队：在队头删除，使用front指针操作。

说明：
出队有两种方式：(a)删除头结点空间;(b)删除出队元素的空间，如果这种方式，在删除最后一个元素时，需要将rear指针赋值为front指针，否则rear成为野指针。


# 实例分析
栈和队列两种数据结构在实际项目中使用较多，这里简单举几个例子。

1. 四则运算表达式求值
	- 需要使用栈完成，涉及两个栈，一个用来存放运算符，一个用来存放操作数。
	- 具体的算法涉及如何将中缀表达式转化为后缀表达式，以及如何用后缀表达式求值，详情参见[栈的应用：四则运算表达式求值][1]。
2. 判断进栈顺序或者出栈顺序的合理性。
	- 一般为面试选择题。通常是已知入栈顺序，求可能的出栈顺序。
	- 思路是按照出栈顺序，判断目前栈顶的元素是否与之相等，如果相等则出栈，如果不相等，则继续入栈。详情参见[面试题之判断栈的入栈和出栈序列的合法性][2]。
	- 扩展问题是已知某种入栈顺序，求所有可能的出栈顺序。详情参见[所有可能的出栈序列问题及卡塔兰数的应用][3]。
3. 两个堆栈实现一个队列
	- 入队，直接压栈到stack1。
	- 出队，判断stack2是否为空，若为空则将stack1中所有元素全部出栈压入stack2,如果不为空直接弹出stack2中数据。（除了连续进栈出栈操作，也适合不连续入栈出栈的情况）。详情参见[两个栈实现一个队列][4]。
4. 两个队列实现一个堆栈
	- 入栈，直接入队queue1。
	- 出栈，将queue1中除最后一个元素外的所有元素出队，再入队queue2，queue1中最后一个元素出队即可。下一个元素出栈，以此类推，再将queue2中元素除最后一个出队并入队到queue1。详情参见[栈和队列高频面试题精讲_七月算法出品][5]。
5. 两栈共享存储空间
	- 两栈共享存储空间适合于两个栈的数据具有相同数据类型，且空间需求为相反关系的情况，使用顺序栈实现。
	- 入栈就是向中间靠拢，出栈就是向两边移动。具体入栈和出栈的操作参见[两栈共享空间][6]。
6. 球钟问题
	- 利用球的移动来记录时间的简单装置，包含一个球队列和三个指示器(分钟/五分钟/小时)。分钟指示器最多装4个球，第五个向前进一位即进入五分钟指示器，同时前4个球按照进入指示器相反的顺序加入球队列的队尾。同理，五分钟指示器最多容纳11个球，小时指示器可容纳11个球。
	- 假设初始有27个球，问经过多久球队列回复到原来的顺序。
	- 该问题涉及到队列和栈的使用，具体代码参见[球钟问题][8]或[球钟问题的解决--栈和队列 ][9]。
7. 队列在实际项目中的应用多为通信发送消息和接收消息的处理或者多任务分时服务系统。可能与之相关还有一些知识点，例如消息队列等，后续结合多线程、进程间通信等内容再做深入讨论。

# 个人观点
1. 只需要理解线性表的存储模型，再结合栈和队列的特点，做相应的改动即可。另外数据存储模型中即结构体，只是规定了必须的成员，其他的成员可以根据实际情况进行增加。
2. 实例分析中主要掌握利用某种数据结构的算法思路，这里未给出具体代码实现，后续有需求再做深入探究。
3. 到此，学习了线性表的顺序存储和链式存储，以及两种特殊的线性表：栈和队列。各种数据结构都有各自的特点，选择时应结合实际需求进行合理的选择。参见[常见数据结构应用场景][7]。

[1]: http://blog.csdn.net/lub0807/article/details/37884417
[2]: https://www.cnblogs.com/MrListening/p/5775909.html
[3]: https://www.cnblogs.com/fxplove/articles/2500898.html
[4]: https://www.cnblogs.com/tracyhan/p/5490775.html
[5]: https://wenku.baidu.com/view/3eff617480eb6294dc886c91.html
[6]: https://www.cnblogs.com/muzijie/p/5655305.html
[7]: https://www.cnblogs.com/lz3018/p/5932198.html
[8]: http://www.embedu.org/Column/Column414.htm
[9]: http://blog.csdn.net/createchance/article/details/17466053