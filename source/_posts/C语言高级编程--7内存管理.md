---
title: C语言高级编程--7内存管理
date: 2017-12-25 09:21:15
categories: 嵌入式
tags: [嵌入式,学习笔记,内存管理,malloc,free]
comments: true

---
>本篇围绕C语言内存管理，讨论了变量存储模型、程序内存分配以及动态内存分配的使用方法，以及其使用注意事项，这些内容需结合函数、指针等知识进行综合分析。<!-- more -->

# 存储模型
- 变量是对程序中数据的存储空间的抽象。一个变量可以通过**存储期、作用域、链接点**来描述。
- 存储期（生命期）：表示变量在内存中保存的时间。分为静态变量和动态变量。静态变量是编译时分配存储空间，从程序开始到程序结束。文件作用域的变量具有静态存储期。动态存储变量在程序执行中使用它时才分配存储空间，使用完立即释放。代码块作用域具有动态存储期，例如函数的形参。函数定义时并不给形参分配存储空间，只有在函数被调用时，才予以分配。
- 作用域：表示变量出现有效区域。分为三种，代码块内作用域（即局部变量的情况）、函数原型作用域（从变量定义处到原型声明末尾，编译器只关心参数类型，不关心名字）、文件作用域（函数之外定义的变量具有文件作用域，也称为全局变量）。
- 链接点：用来说明程序哪些部分可以使用该变量。分为内部链接（一个文件内有效，使用static）、外部链接(一个或多个文件有效)、空链接（代码块作用域或者函数原型作用域）。

## 分类
从存储期、作用域、链接点三个方面考虑，将变量的存储模型分为五类。

- 自动：使用关键字auto，可省略。一个代码块内或者函数头部声明的变量，即所谓的普通局部变量，具有动态存储期，代码块作用域、空链接。如果未初始化，则值不确定。
- 寄存器: 使用关键词register，具有自动存储期、代码块作用域和空链接。由于变量在寄存器中，不能使用取地址运算符获取变量的地址。未初始化则值不确定。
- 具有外部链接的静态：在所有函数外定义未使用static修饰的变量，即通常的全局变量，具有静态存储期，文件作用域和外部链接。仅在编译时初始化一次，默认为0,如果要在其他文件中使用，需要使用关键词extern。通常在.c文件定义，在.h文件中声明为外部变量。但不能在头文件为变量赋初值。
- 具有内部链接的静态：使用static修饰的全局变量，具有静态存储期、文件作用域、内部链接，只能在同一个文件中使用。仅在编译时初始化一次，默认为0。
- 空链接的静态：即static修饰局部变量，具有静态存储期、代码块作用域和空链接，仅在编译时初始化一次，默认为0。适用于多次调用函数且要求保留这些变量的值，可以考虑使用静态局部变量。

说明：

1. 存储期是从时间上考虑变量，而作用域是从空间上考虑变量。要注意区别。
2. 在函数专题中，提及函数返回值不能是局部变量，可以是静态局部变量或者堆上的内容。
3. 注意区分一些概念。例如动态存储期。动态存储期是指局部变量空间在使用时才分配，且使用完就释放了，是相对于静态存储期而言。而动态分配是指程序员可以自己手动分配内存空间，是相对于自动分配而言。
4. static关键词的作用：
	- 修饰全局变量，限制其作用域，只能在本文件中使用。
	- 修饰局部变量，扩展其生存期，其值能保持到下一次调用，到程序结束时释放。
	- 修饰函数，限制其作用域，只能在本文件中使用。

*参考文献：*
*[C语言编程之存储模型、链接][1]*
*[C语言存储模型][2]*

# 内存分配
一个在运行的C语言程序占用内存的情况，分为以下几个区域：

- 代码区：只读，存放CPU执行的机器指令。
- 已初始化的全局数据与静态数据区：包括全局变量、静态变量（全局或局部）、常量数据（如字符串常量）。
- 未初始化数据区：即BSS区，存放未初始化的全局变量。
- 堆区：用于动态分配内存。位于BSS区和栈区之间。
- 栈区：存放函数参数、局部变量等。

说明：

1. 这里的堆区别于数据结构中的堆，类似于链表。这里的栈，类似于数据结构中的栈，符合先进先出的规则。
2. size exename可以看到可执行文件各个区的大小，包括text、data、BSS，这里没有堆和栈，是存储时的三个区域，当程序执行时，才会有堆和栈。
3. ulimit -a命令可以查看资源限制的设定，包括栈空间、可打开的文件数等。
4. 堆和栈的区别如下：
	- 管理方式：堆区空间申请和释放需要程序员控制，而栈区由编译器自动管理。
	- 空间大小：堆区内存不连续，空间大，而栈区连续空间，空间较小。
	- 是否产生碎片：堆区需要频繁的malloc，容易造成内存空间不连续，产生碎片。
	- 增长方向：堆区向着内存地址增加的方向，**栈区向着内存地址减小的方向**。
	- 分配效率：堆区的效率低于栈区。

*参考文档：*
*[C语言中内存分配][3]*

# 动态内存
- 通常情况下，编译器根据变量的类型知道所需的内存空间，在合适的时间分配确定的存储空间。在栈上创建局部变量，函数执行完毕自动释放存储单元，效率高，但分配的内存空间有限。该方式的分配和释放都是自动进行。
- 而有的情况只有在程序运行的时候才能确定内存分配大小，系统根据运行时的要求进行内存分配，称为动态存储分配。动态存储分配在堆上进行。使用malloc函数手动分配，使用free函数手动释放，因此其生存期由程序员决定。
- 对于动态分配的内存唯一的访问方式是通过指针间接访问。malloc函数在内存中动态的分配一个长度为size的连续空间，返回指向所分配连续空间起始地址的指针。内存空间有限，须在不用时，使用free函数显示释放空间。函数原型如下：

malloc函数
```
void *malloc(size_t num);
```
free函数
```
void free(void *p);
```

说明：

1. malloc函数本身并不识别要申请的内存是什么类型，只关心申请内存的大小。在实际调用中，需要显示的进行强制类型转换。如果申请失败，返回NULL，因此要做错误判断。
2. 堆区不会自动在分配时初始化，**必须显示的进行初始化**。例如：memset(p,0,n*sizeof(int));这一点在实践中应该注意。
3. 分配的内存如果操作越界，会造成不可估量的后果，比如给char类型指针动态分配空间，需要考虑'\0'的存储空间。
4.  使用堆上的空间，必须记得使用free释放，且只能释放一次。如果忘记释放，则会造成内存泄露。如果释放多次也会出错。
5. free 不允许释放部分内存。即free(p+2)是错误的。必须提供释放内存的起始地址。
6. free只是告诉系统这段空间不使用了，可以再次分配。但是其空间上的内容尚未改变，还可以访问，因此free后，通常置指针为NULL。释放的是堆空间，指针P在栈上，还指向原来的位置，因此可以访问，所有让其置NULL。
7. free只能释放堆空间。代码区、全局变量、静态变量区、栈区上的指针变量都不能用free释放空间。
8. malloc与free必须配对使用。不需要的内存空间都需要释放回收。
9. 在函数内建立的动态对象在函数外仍然可以使用，这就是为什么函数可以返回堆上的地址的原因。因此堆上的空间称为自由空间。在函数运行时才能确定大小的情况，通常会在函数内动态分配内存并返回指针。但是在函数内申请动态空间而在函数外释放是一件很容易失控的事情，往往会出错。此种情况，要保证指针起始位置的正确赋值，并在函数外不使用指针时及时释放。
10. 关于野指针：指向垃圾内存的指针。形成原因：（1）指针没有初始化；（2）指针free后没有置NULL。（3）指针操作超过了变量的作用范围，访问了非法内存。（4）返回指向栈内存的指针。
11. 关于野指针会造成什么后果是难以估计的。若内存暂时空闲，可能程序正常运行，若内存再次被分配，又通过野指针对内存进行写操作，则原有合法数据会被覆盖。尽量应避免出现野指针。即指针初始化时置NULL，使用完毕释放后再次置NULL。

*参考文档：*
*[C动态内存分配：（三）malloc/calloc/realloc/free使用注意事项 ][4]*
*[浅谈C语言内存管理、内存泄露、堆栈][5]*
*[结构体指针内的指针变量成员的内存分配][6]*
*[结构体内指针字符数组的释放][7]*
*[free函数的实质][8]*

# 个人观点
对于本节内容，主要是要掌握动态内存分配使用的各种注意事项，在实践中避免不规范的使用造成的内存错误。结合前面总结的指针、函数等内容综合分析。

[1]: http://blog.csdn.net/sinat_16046537/article/details/51718837
[2]: https://www.cnblogs.com/wanglun/p/7114817.html
[3]: http://blog.csdn.net/youoran/article/details/10990815
[4]: http://blog.csdn.net/zxx910509/article/details/63277561
[5]: https://www.cnblogs.com/youthshouting/p/4280543.html
[6]: http://blog.csdn.net/h542723151/article/details/43422711
[7]: http://ask.csdn.net/questions/207027
[8]: https://zhidao.baidu.com/question/516360949.html
