---
title: C语言高级编程--6用户自定义数据类型(结构体)
date: 2017-12-15 09:21:15
categories: 嵌入式
tags: [嵌入式,学习笔记,结构体,共用体,枚举,指针]
comments: true

---
> 本篇文章以用户自定义数据类型为核心，重点讲解了结构体使用的相关知识点：包括定义、初始化、使用，结构体数组，结构体指针，以及讨论了一些在实践中需要考虑的问题。最后简要介绍了共用体和枚举。<!-- more -->

# 结构体
## 基本使用
- 结构体是一种构造类型，用户自定义的数据类型。包含多个不同数据类型的数据组合在一起进行描述。其中可以是基本类型也可以是构造类型。
- 结构体的作用：结构体的使用为处理复杂数据结构（如动态数据结构）提供了有效的手段。而且，为函数间传递不同类型的数据提供了方便。

### 结构体变量定义
```
方法1.先定义结构体，再定义变量名。适合于同时定义多个变量。
struct 结构体名
{
	数据类型　成员名１;
	数据类型　成员名２;
	……
	数据类型　成员名n;
};
struct 结构体名　变量名;

方法2.在定义结构体类型的同时定义变量。适合于定义全局结构体。
struct 结构体名
{
	数据类型　成员名１;
	数据类型　成员名２;
	……
	数据类型　成员名n;
}变量名;

方法3.直接定义结构体变量。适合于函数内部或者结构体嵌套，因为其他地方不可以再声明。
struct 
{
	数据类型　成员名１;
	数据类型　成员名２;
	……
	数据类型　成员名n;
}变量名;
```

说明：

1. 在定义结构体时，不占内存空间，只有在定义结构体变量时，才分配内存空间。
2. struct关键字和结构体名必须写在一起，代表结构体类型名。因此为了方便，可以在定义结构体时使用typedef，这样在后面定义变量时则可以少写struct。
3. 一般在头文件定义结构体，如果在定义结构体同时定义结构体变量，则是全局的结构体变量，在其他文件可以包含该头文件，使用该结构体变量，但是不能再定义其他结构体变量。因此定义结构体同时定义结构体变量只适合于该结构体只使用一次的情况。通常的做法是在头文件使用typedef 定义结构体新数据类型，在其他文件定义该数据类型的结构体变量。

### 结构体变量初始化
按照结构体变量定义的方式不同，也有不同的初始化方法。
```
方法1：
struct 结构体名 变量名={初始数据表};

方法2：
struct 结构体名{
	成员列表;
}变量名={初始数据表};
```

说明：
可以对结构体部分成员赋初值。另外，在驱动编程部分也涉及结构体初始化问题。通常写法如下：
```
结构体变量初始化
struct device={
	.id=-1,
	.name="key",
	……
};

结构体数组变量初始化
struct device[]={
	[0]={
		.id=-1,
		.name="key1",
		……
		},
	[1]={
		.id=-1,
		.name="key2",
		……
	},
};
```

### 结构体变量使用
1. 结构体变量的成员表示为：结构体变量名.成员名。
2. 定义了结构体变量后，可以对结构体变量的成员赋值，也可以引用其地址。如果结构体当中又嵌套结构体，则只能一层一层找到最低层进行运算。
3. 不能将一个结构体类型变量作为一个整体引用，只能对结构体变量中的成员加以引用。
4. 同一类型的结构体变量之间可以互相赋值，但是数组不可以互相赋值。赋值后就相当于所有成员被赋值了。
5. 两个结构体变量进行比较，可以各成员逐个比较，也可以使用memcpy比较内存内容。

## 结构体数组与结构体指针
### 结构体数组
1. 首先结构体数组是指数组元素为结构体，那么结构体数组的定义、初始化、使用和结构体变量的定义、初始化、使用类似，此处省略。
2. 其次它又是数组，因此有数组的特性，数组的个数等于sizeof(数组名)/sizeof(结构体名)。
3. 在使用时，结构体数组的元素值可以赋值给同一类型的另一个数组的元素，也可以赋值给同类型的结构体变量，也就是允许结构体之间互相赋值。

### 结构体指针
用一个指针变量指向一个结构体变量，该指针变量的值是结构体变量的起始地址，该指针为结构体指针。

定义：
```
struct 结构体名 *结构体指针名;
```

说明：

1. 在定义结构体变量的同时，也可以定义结构体指针变量，并且使用typedef定义一种新的数据类型。详见[《C语言高级编程--1基础零碎知识》][9]。
2. 定义结构体指针变量只是说明该指针指向这种结构体类型，规定了其数据特性，并为结构体指针本身分配了内存空间，但是指针的内容尚未确定，指向随机的对象。
3. 使用结构体指针访问成员，使用->。

## 扩展问题总结
1. 在实践中经常用到结构体。在项目详细功能设计阶段需要设计项目所需的各个结构体。在阅读开源代码时，也需着重分析核心结构体，例如mosquitto源码、cJSON源码、onvif源码等，其中涉及的结构体举例详见[gist][10]。
2. 结构体可以理解为面向对象编程语言中的对象，其中普通数据类型的成员相当于属性，函数指针成员相当于方法。
3. 结构体中成员为函数指针：通常会在某个函数里赋初值，即赋值为某函数名(回调函数)。然后使用结构体成员调用函数，即会执行回调函数。
4. 结构体中成员要使用字符串，可以用字符数组也可以使用字符指针。但是使用字符指针，需要使用malloc先动态分配内存，才可以赋值内容。字符数组和字符指针赋值，即填充字符串，都使用strcpy，strncpy，snprintf等函数，但需要注意这些函数各自的特点。
5. 如果函数返回结构体指针，在函数体内对结构体填充内容，首先需要对结构体指针malloc动态分配内存。如果其中成员含有字符指针，需要使用malloc二次动态分配空间填充字符串。
	- 为结构体指针分配动态内存时，只是为其中字符指针成员分配空间，并没有为其指向的字符串分配空间，因此需要二次分配。	
	- 注意free的时机，两次分配的内存空间并不连续。如果在函数外需要访问结构体内容，访问完毕需要先释放字符指针成员的空间，再释放结构体指针的空间。且不可以在函数内释放字符指针成员空间。
	- 正是由于第二点使用的不方便，可以定义零长度数组成员，实现连续空间的分配和释放，详见参考文档[《C语言结构体里的成员数组和指针》][4]。
6. 关于结构体作为函数返回值：如果返回结构体，在函数内错误处理不便于返回。若返回结构体指针，出错时可以返回NULL。
7. 关于结构体做形参：若使用结构体做形参，需要大面积赋值，且也不能改变实参的值，因此多使用结构体指针做形参。
8. 关于函数返回结构体指针和函数形参为结构体指针的选择：和其他函数考虑一样，如果是在函数内确定结构体数组大小，返回动态分配的内存内容，考虑返回结构体指针。如果要返回多于一个返回值，考虑使用多个形参。

使用示例：
```
头文件 b.h：
#ifndef _B_H_
#define _B_H_
typedef struct{
	int num;
	char *name;
}student,*student_t;
#endif

main.c
#include <stdio.h>
#include <stdlib.h>
#include "b.h"
student_t set_info()
{
	int n = 2;

	//为结构体指针分配空间
	student_t studentP=(student_t)malloc(sizeof(student)*n);

	//64位系统，8字节对齐
	printf("%lu\n",sizeof(student));//16
	printf("%lu\n",sizeof(int));//4

	printf("%p\n",studentP);
	printf("%p\n",&studentP[0].num);
	//只是分配了存放指针成员的内存空间，指针指向的内容空间没有分配
	printf("%p\n",&studentP[0].name);
	printf("%p\n",&studentP[1].num);
	printf("%p\n",&studentP[1].name);

	studentP[0].num=1;

	//为字符指针成员所指向的内容分配空间
	studentP[0].name = (char *)malloc(sizeof(char)*10);

	//使用snprintf赋值
	snprintf(studentP[0].name,10,"%s","youbo");

	studentP[1].num=2;
	studentP[1].name = (char *)malloc(sizeof(char)*10);
	snprintf(studentP[1].name,10,"%s","xiaozhao");

	//其值为所指向字符串的首地址，和前面的地址并不连续
	printf("%p\n",studentP[0].name);
	printf("%p\n",&studentP[0].name[0]);
	printf("%p\n",&studentP[0].name[1]);
	
	printf("%p\n",studentP[1].name);
	printf("%p\n",&studentP[1].name[0]);
	printf("%p\n",&studentP[1].name[1]);

	//如果在该处释放后，函数外不能访问内容
	//free(studentP[0].name);
	//free(studentP[1].name);
	return studentP;
}

int main(int argc,const char *argv[])
{
	student_t studentP = NULL;
	studentP = set_info();

	printf("%d %s\n",studentP[0].num,studentP[0].name);
	printf("%d %s\n",studentP[1].num,studentP[1].name);

	free(studentP[0].name);
	free(studentP[1].name);
	studentP[0].name = NULL;
	studentP[1].name = NULL;
//	printf("%s\n",studentP[0].name);
	free(studentP);
	
//	如果不释放studentP[0].name,只释放studentP,在置NULL之前还可以访问成员指向的内容
//	printf("%s\n",studentP[0].name);

	studentP = NULL;
	
//	置NULL后再访问一定会出现段错误，可以避免错误。
//	printf("%s\n",studentP[0].name);

//	必须在studentP释放之前释放指针成员空间
//	free(studentP[0].name);
//	free(studentP[1].name);
//	studentP[0].name = NULL;
//	studentP[1].name = NULL;

	return 0;
}
```

*参考文档：*
*[c语言里用结构体和指针函数实现面向对象思想][1]*
*[对结构体中字符串指针和字符数组赋值的区别是什么][2]*
*[C语言，结构体中字符串的声明（采用字符指针还是字符数组）][3]*
*[C语言结构体里的成员数组和指针][4]*
*[strcpy和strdup比较和详解][5]*
*[结构体内的指针需要逐个释放吗？][6]*

# 位域
位域是指把一个字节的二进位划分为不同的区域，并说明每个区域的位数。每个域有一个域名，允许程序按域名操作。这样可以将几个不同对象用一个字节的二进制位域来表示，从而可以节约空间。

定义：
```
struct 位域结构体名
{
	类型说明符　位域名:位域长度;
};
```

使用示例:
```
linux内核源码　
linux-3.14/include/linux/tcp.h
struct tcphdr {
	__be16	source;
	__be16	dest;
	__be32	seq;
	__be32	ack_seq;
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u16	res1:4,
		doff:4,
		fin:1,
		syn:1,
		rst:1,
		psh:1,
		ack:1,
		urg:1,
		ece:1,
		cwr:1;
#elif defined(__BIG_ENDIAN_BITFIELD)
	__u16	doff:4,
		res1:4,
		cwr:1,
		ece:1,
		urg:1,
		ack:1,
		psh:1,
		rst:1,
		syn:1,
		fin:1;
#else
#error	"Adjust your <asm/byteorder.h> defines"
#endif	
	__be16	window;
	__sum16	check;
	__be16	urg_ptr;
};

```

说明:

1. 位域不可以跨越字节，如果剩下的位不足以存放一个位域时，应该从下一单元起存放该位域，而上一字节剩下的部分用无名的位域来填充。
2. 位域其实是一种结构类型，只是其成员是按照二进制位进行分配。
3. 位域变量定义和使用方法都和结构体类似，此处省略。
4. 位域在实践中用的较少，仅作了解。

# 共用体
共用体又称为联合体。其定义、初始化、使用方法和结构体类似，但是在使用内存上有所不同。
特点：

1. 不同数据类型的数据使用共同的存储空间。
2. 由于第一条的特点，因此各个成员的首地址相同。
3. 由于第一条的特点，因此共用体变量起作用的成员是最后一次存放的成员，新的成员值会将旧的成员值覆盖。
4. 共用体用在各数据类型占用空间差不多，且对各变量同时使用要求不高的场合。例如共享内存，每次只用到其中一个成员的情况。

使用示例：
```
e.g1
信号灯集操作函数,第四个参数是一个共用体，适用于不同的情况。
 int semctl(int semid, int semnum, int cmd, ...);
 union semun 
 {
	int   val;    /* Value for SETVAL */
 	struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */
 	unsigned short  *array;  /* Array for GETALL, SETALL */
  	struct seminfo  *__buf;  /* Buffer for IPC_INFO (Linux-specific) */
};

e.g2
共用体测试字节序是大端还是小端
union gy{
	char a;
	short b;
	int c;
};
union gy t;
t.c = 0x12345678;
printf("%#x %#x %#x\n",t.a,t.b,t.c);
```

*参考文档*
*[联合体（union）的使用方法及其本质][7]*
*[共用体的定义与应用详细解析][8]*

# sizeof作用于结构体和共用体
1. 不考虑字节对齐，结构体的大小是所有成员大小之和。
2. 不考虑字节对齐，共用体的大小是成员中占字节最大的字节数。
3. 如果考虑字节对齐，结构体大小可能会变大，32位机4字节对齐，64位机8字节对齐。
4. 如果考虑到对齐原则，那么定义结构体时，尽量注意顺序，4字节成员放前面，接着是2字节成员，最后是1字节成员。
5. 如果出现某个数据总是与期望的不符，但不会波动，要考虑字节未对齐的问题。

*参考文档：*
*[C语言字节对齐问题详解（对齐、字节序、网络序等）][11]*

# 枚举
枚举用于变量取值有限的情况。
定义：
```
enum 枚举名{
枚举列表
};
```

说明：
1. 如果不写取值，默认从0开始，是整型数据。如果想要改变，可以自定义每一个成员等于几。
2. 如果没有显式赋值的成员值总是在前一个枚举成员的值上加１，允许不同成员具有相同的值。
3. 枚举变量的定义，使用都是和结构体共用体类似，此处省略。
4. 枚举是一种基本数据类型，因为其不可再分。

# 个人观点
1. 至此，完成了C语言中四个重要知识点的梳理，包括数组、指针、函数、结构体。
2. 总结起来，讨论了两个内容，一是数据类型：数组、指针、结构体。二是函数。而函数中有形参和返回值，这些都是变量，因此又和数组、指针、结构体等数据类型产生关系。因此需要综合考虑。
3. 应先理解每一个知识点的含义，再进行组合考虑。比如数组指针、指针数组、字符数组、字符指针、函数指针、指针函数、函数指针数组、函数传递指针、函数传递数组、函数传递字符数组、函数传递字符指针、函数传递结构体、函数传递结构体指针、函数返回指针、函数返回指向数组的指针、函数返回结构体 、结构体指针、结构体数组、结构体成员为字符数组、结构体成员为字符指针、结构体成员为函数指针。
4. 要理解各个内容是在什么情况下使用，有什么特点好处，才会在遇到同样的情况下有意识的去使用这个知识点。

[1]: https://www.cnblogs.com/stormpeach/p/4366294.html
[2]:http://bbs.csdn.net/topics/390126411
[3]: http://blog.csdn.net/u013485792/article/details/52807056
[4]: http://developer.51cto.com/art/201404/434678.htm
[5]:http://blog.csdn.net/koozxcv/article/details/49306751
[6]: https://segmentfault.com/q/1010000004469879
[7]:https://www.cnblogs.com/tianlangshu/p/5204521.html
[8]:http://www.jb51.net/article/41027.htm
[9]: http://www.youbo.website/2017/11/14/C%E8%AF%AD%E8%A8%80%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B--1%E5%9F%BA%E7%A1%80%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/
[10]: https://gist.github.com/youxiaobo/8b2c20323bd1c936fc4425e837d1a06c
[11]: https://www.cnblogs.com/prettyshuang/p/5553140.html