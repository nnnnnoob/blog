---
title: 数据结构--3树和图
date: 2018-01-16 09:21:15
categories: 嵌入式
tags: [嵌入式,学习笔记,树,图]
comments: true

---
>本篇总结两种非线性数据结构：树和图。树的内容中主要讨论二叉树的性质、存储和四种遍历方法。图主要讨论基本概念，邻接矩阵表示法的存储结构和广度优先、深度优先两种遍历算法。树和图在实践项目使用中较少，了解基本概念即可。<!-- more -->

# 树
## 基本概念
- 树是n个节点的有限集合，满足两个条件：(1)有且仅有一个特定的称为根的节点。(2)其余的节点分为m个互不相交的有限集合，其中每一个集合又是一棵树，称为根的子树。
- 节点的度数：节点的子树个数。
- 树的度数：节点中的最大度数。
- 节点的层数：父节点层数+1，根节点层数为1。
- 树的高度（深度）：节点层数的最大值。

## 树的逻辑结构
- 树中任何节点都可以有零个或多个直接后继节点，至多一个直接前驱节点。
- 根节点没有直接前驱节点。
- 叶子节点没有直接后继节点。

## 二叉树
### 定义
- 二叉树是n个节点的有限集合，它要么是n=0为空集，要么是由一个根节点以及两颗互不相交、分别称为左子树和右子树的二叉树组成。
- 二叉树严格区分左孩子和右孩子，即使只有一个子节点。

### 性质
- 第i层上的节点最多2^(i-1)个。
- 高度为k的二叉树最多有2^k-1个节点。
- 树叶的数目比度为2的节点数目多1。
- 满二叉树：高度为k时，有2^k-1个节点。
- 完全二叉树：只有最下面两层有度数小于2的节点，且最下面一层的叶节点集中在最左边若干位置。深度为⌊log2n+1⌋或者⌈log2(n+1)⌉。

### 顺序存储结构
- 完全二叉树可以按照从上到下、从左到右的顺序为每一个节点编号，然后用一维数组存储，就是完全二叉树的顺序存储。
- 一般二叉树可以添加虚节点，成为完全二叉树，然后按照完全二叉树的方式进行顺序存储,如下图所示。
- 特点是：如果是完全二叉树，则存储结构既简单又节省空间。如果是一般二叉树，则存在空间浪费的情况。

![](http://osjn6k0nm.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8.jpg "二叉树的顺序存储")

注：关于顺序存储的具体结构体实现此处省略，参见参考文档。

*参考文档：*
*[二叉树的存储结构][1]*
*[树的三种存储结构][2]*
*[二叉树的顺序存储][3]*

### 链式存储结构
二叉树的链式存储，每个节点包括数据域存储数据，指针域存储左孩子和右孩子指针，如图所示。

![](http://osjn6k0nm.bkt.clouddn.com/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8.jpg "二叉树的链式存储")

其实现的结构体如下：
```
typedef int data_t;//定义数据类型
typedef struct node_t{ //定义二叉树内部结点
	data_t data; //数据域
	struct node_t *lchild,*rchild; //指向左孩子和右孩子的指针
}bitree_t;
bitree_t *root; //根节点
```

### 数据运算：遍历
- 对于二叉树的数据运算有建立空的二叉树、求根节点、求双亲结点、求左右孩子结点、插入左孩子或右孩子、删除左孩子或右孩子、遍历等，这里只谈遍历的几种方法。
- 遍历是指沿着某条搜索路径周游二叉树，对树中每个节点访问有且仅有一次。注意，遍历是任何类型均有的操作，对于线性结构，因为只有一条搜索路径因此不做讨论。但是二叉树有两个直接后继，因此有不同的搜索路径。
- 根据根的访问次序，分为三种：前序遍历(根左右)、中序遍历(左根右)、后序遍历(左右根)。此外还有一种按层次遍历。
- 遍历操作是将非线性结构线性化的过程。许多其他操作都是在此基础上进行扩展。

说明：

1. 先序、中序、后序遍历三种算法的实现十分简单，理解原理即可，使用递归的方式完成，这是由二叉树的递归定义决定的。
2. 层次需要利用链式队列的入队和出队，这里队列的数据类型是二叉树指针，当出队时返回指针，就可以知道左孩子和右孩子。
3. 关于先序、中序、后序三种遍历方式，面试题中考题有两种：(a)根据二叉树的结构图，求出某一种遍历顺序。(b)根据两种遍历方式求第三种遍历方式和二叉树结构图。需要注意的是必须已知中序遍历。先序和后序不能唯一确定二叉树。
4. 由遍历顺序确定二叉树结构图时，注意各种遍历方法的特点，例如先序是根左右，中序是左根右，后序是左右根，因此先序序列中第一个结点是根节点，然后在中序中找到根节点，则根节点以左为左子树，根节点以右为右子树。
5. 在确定某一种遍历顺序时，要记住一条原则：如果遇到没有遍历的结点，当做根节点处理。

扩展：求二叉树的深度

1. 求二叉树的深度也是基本的运算，可以采用后序遍历的思想完成。
2. 先求左右子树的高度，再求根的高度，根的高度为左子树高度加1和右子树高度加1中的较大者。参见[求二叉树的高度][6]。

# 图
## 基本概念
- 图是一种比线性表和树更为复杂的数据结构。树是图的特例，有向无环图。
- 图的形式化描述：G=(V,R)。V是图中元素顶点的集合，R是顶点之间的关系集合。
- 基本术语包括：有向图、无向图、路径、网、顶点的度、连通性等，此处省略。
- 图的逻辑结构中结点之间是多对多的关系，根据是否有向、是否有权值、是否连通等特点会有不同的结构，此处省略。

## 存储结构
- 图的存储结构不能再使用顺序存储和链式存储表征结点与结点之间的关系。这里图有五种存储结构：邻接矩阵、邻接表、十字链表、邻接多重表、边集数组等。这里只谈**邻接矩阵**方法。
- 邻接矩阵表示法(数组表示法)即用二维数组表示图，邻接矩阵是一个方阵，行和列都表示顶点，其值表示为两个顶点之间的关系。如果有关系则为1,如果没有关系则为0。
- 对于在图的关系上附加一个权值的，称为网。网的邻接矩阵则是，如果有关系则为w,如果没关系则为无穷大。

邻接矩阵方法的结构体实现如下：

```
#define MAXN 64 //最大顶点数
typedef char vtype; //定义顶点数据类型
typedef int adjtype; //邻接矩阵中的元素
typedef struct{
	vtype V[MAXN];//顶点存储空间
	adjtypde A[MAXN][MAXN];//邻接矩阵
}mgraph;
```

*参考文档*
*[图的五种存储结构][5]*

## 数据运算：遍历
- 图的数据运算包括：建立一个图、定位结点位置、取第i顶点、取第一邻接点、插入顶点、插入弧或边、删除顶点、删除弧或边、遍历等，这里只谈遍历。
- 图的遍历有两种：深度优先遍历，类似于树的先序遍历。广度优先遍历，类似于树的层次遍历。

说明：

1. 这里是以邻接矩阵表示法构成的无向图，讨论深度优先遍历和广度优先遍历。
2. 深度优先遍历使用递归完成，广度优先遍历使用链式队列入队和出队完成。
3. 主要是理解算法原理。
4. 深度优先搜索和广度优先搜索有各自适合的应用场景，需要时可做深入分析，参见[什么时候用DFS，什么时候用BFS?(DFS和BFS的特点和异同)][7]。

# 个人观点
- 关于树和图的基本概念参见[数据结构自考网][4]。
- 对于树和图的掌握：了解基本概念，掌握树和图的遍历方法。在实践项目中很少使用树和图这两种数据结构，一般在面试题中考察。
- 对于使用递归的算法，编程实现上是非常简单的，只需要想清楚何时递归，退出条件是什么等问题即可。例如链表的逆序输出、二叉树的遍历，二叉树的高度求解、图的DFS等都可以使用递归的方法。
- 至此，总结了线性表、栈、队列、树、图几种数据结构及其基本操作，如数据结构系列文章第一篇所述，可将这些数据结构的操作代码形成模板，当做工具使用，详见[GitHub][8]。

[1]: https://www.cnblogs.com/pengyingh/articles/2396466.html
[2]: http://blog.csdn.net/x1247600186/article/details/24670775
[3]: http://blog.csdn.net/kongkongl/article/details/38764101
[4]: http://student.zjzk.cn/course_ware/data_structure/web/shu/shu6.1.1.1.htm
[5]: http://blog.csdn.net/woshisubeibei/article/details/18962349
[6]: http://blog.csdn.net/chenyufeng1991/article/details/52724988
[7]: http://blog.csdn.net/cqztw/article/details/72921853
[8]: https://github.com/youxiaobo/data-structure