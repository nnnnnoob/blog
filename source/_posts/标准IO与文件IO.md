---
title: 标准IO与文件IO
date: 2018-02-28 09:21:15
categories: 嵌入式
tags: [嵌入式,学习笔记,标准IO,文件IO]
comments: true

---
>前面从linux操作系统使用、C语言高级编程、数据结构三个方面总结了嵌入式linux开发基础相关的内容。从本篇开始，进入嵌入式linux应用层开发的知识总结。应用层开发知识梳理表面上来看，就是讲解函数的使用方法。那么这就包括理解函数的原理、根据需要选择合适的函数。
嵌入式linux是由linux裁剪而来，其系统调用和用户编程API和linux基本一致。因此一般的思路是学习linux相关内容的基本编程开发，再移植到嵌入式开发板中运行。这一点对于第三方库移植也有借鉴思路，先在linux环境下实验，再移植到嵌入式环境中，比如onvif移植。
本篇文章从系统调用、库函数等概念引入，详细说明了标准IO和文件IO中重要函数的使用。<!-- more -->

# 先导概念
## 系统调用
- 系统调用是指操作系统提供给用户程序调用的一组特殊接口。用户程序可以通过这组接口来获得操作系统内核提供的服务。
- 关于内核态和用户态：出于对内核空间安全保护的考虑，将程序运行的空间分为内核空间和用户空间，它们分别运行在不同的级别上，逻辑上相互隔离。通常情况下，用户进程不能访问内核数据，也无法使用内核函数。如果用户空间要使用系统服务，即调用内核空间程序，那么就需要通过系统调用，规定用户进程进入内核空间的具体位置。进行系统调用，程序运行空间需要从用户空间进入内核空间，处理完后返回用户空间。**这就是为什么强调不要频繁陷入内核态的原因**。
- 系统调用是通过软中断的方式向内核提交请求以获得内核服务的接口。linux系统调用继承了unix的系统调用，包括进程控制、进程间通信、文件系统控制、系统控制、存储管理、网络管理、socket控制、用户管理等。
- 系统调用是用户空间进程访问内核的接口。把用户从底层的硬件编程中解放出来。极大的提高了系统的安全性，使用户程序具有可移植性。

## 库函数
- 库函数是为了实现某个功能而封装起来的API集合，提供统一的编程接口，更加便于应用程序移植。
- 库函数相当于是对系统调用的又一层封装。库函数是面向程序员的应用编程接口，是在用户空间。
- 一个库函数有可能含有一个系统调用，也有可能有好几个系统调用，也有可能没有系统调用，比如有些操作就不需要涉及内核的功能。

## 两者的联系区别
- 使用man man命令可以看到2为系统调用，3是库函数。
- 库函数是在用户空间，而系统调用是在内核空间。
- 库函数多用于普通文件读写，而系统调用多用于底层文件访问，例如驱动程序中对设备文件的访问。
- 系统调用和库函数从实现者角度看有本质区别，但是对于用户来说，**都是以C函数形式出现**。
- 系统调用和库函数是调用函数的两种方式，用户可以使用库函数也可以使用系统调用。
- 注意相关概念：用户编程接口API，通常是指库函数。用户编程接口要遵循POSIX标准，由IEEE和ISO/IEC共同开发。主要是通过C库（libc）实现。
-注意相关概念：系统命令，是可执行文件，相对于API更高一层。它的内部引用了用户编程接口来实现相应功能。因此会看到许多同名的命令和函数。
- 具体的系统调用函数和库函数可以参考《UNIX程序员手册》第二、三章内容。

*参考文档：*
*[深入理解系统调用与库函数调用][1]*
*[Linux系统调用及用户编程接口(API)][2]*
*[系统调用与库函数调用][3]*
*[库函数与系统调用][4]*
*[C标准库，系统调用，系统接口API，内核函数 ][5]*

# 标准IO
## 基本概念
### 概述
- 标准IO库由ANSI C标准说明。
- 标准IO库处理很多细节，比如**缓冲区分配**，以优化的块长度执行IO，使用户不必关心如何选择合适的块长度。
- 标准IO库在系统调用函数基础上构造，便于用户使用。
- 标准IO库以及其头文件stdio.h为底层IO系统调用提供了一个通用的接口。

### 流与FILE对象
- **标准IO的所有操作都是围绕流**来进行，所有IO操作仅是简单的从程序移进或移出，这种字节流称为流。流用FILE *表示。
- 流分为文本流和二进制流。文本流：在流中处理的数据是以字符出现。二进制流：流中处理的数据是二进制序列。
- FILE *是文件指针。每个被使用的文件都在内存中开辟一个区域，用来存放文件的相关信息，这些信息保存在一个系统定义的结构体中，即FILE。信息中包括实际IO文件描述符，缓冲区的长度，当前缓冲区的字符数等。
- 在/usr/include目录下使用“ctags -R”生成tags文件，使用“vi -t FILE"查看FILE结构体的定义在libio.h中。
- 标准IO预定义了三个流，包括标准输入stdin、标准输出stdout、标准错误输出stderr，它们都是FILE *类型。

### 缓冲
- 标准IO库提供缓冲的目的是尽量少使用read/write调用。
- 系统自动在内存中为每一个正在使用的文件开辟一个缓冲区，从内存向磁盘输出数据必须先送到内存缓冲区，装满缓冲区后再一起送到磁盘中。如果要从磁盘读数据，则一次从磁盘文件将一批数据读入内存缓冲区，再从缓冲区逐个将数据送到程序的数据区。
-  缓冲分类：全缓存，行缓存，不带缓存。
	- 全缓存：当填满IO缓存后才进行实际的IO操作。进行IO操作是指调用read/write。对于驻留磁盘上的文件就是实施全缓冲。在流上执行第一次IO操作时，通常调用malloc获取需使用的缓冲区。刷新条件：缓存满、程序正常结束、fflush。
	- 行缓存：当输入输出遇到'\n'，进行IO操作。当流涉及到终端时就是典型的行缓存。刷新条件：'\n'、缓存满、程序正常结束、fflush。
	- 不带缓存：不对字符进行缓存，标准出错通常是不带缓存的。
- 使用setbuf和setvbuf函数可以更改缓存类型。
- 使用fflush可以强制刷新一个数据流。fflush是针对写操作，将缓冲区的数据写到磁盘中。当代码的执行现象和预估不一致时，要考虑是否是和缓冲有关，必要时使用fflush强制刷新。
- 标准IO是带缓存的IO，这里的缓冲区是在**用户空间的流缓存区**。

```
示例1：
#include <stdio.h>
int main(int argc,const char *argv[])
{
	while(1)
	{
		fputc(fgetc(stdin),stdout);	
	}
	return 0;
}
该程序是循环从标准输入读入，并逐个字符显示在标准输出上。运行现象是输入一些字符后，按回车，显示所有字符，再继续敲入一行，显示一行。这就是因为标准输入标准输出是行缓存，遇到'\n'刷新。

示例2：
/*
 * 生成二叉树
 * 这里输入字符序列是按照先序输入
 * 根左右
 * */
bitree_t bitree_create()
{
	datatype_t ch;
	scanf("%c",&ch);//这里有输入的缓冲机制，必须要输入正确个数，递归才会结束
	if(ch == '#') //这里认为输入#表示该位置没有数据
	{
		return NULL;
	}

	bitree_t root = NULL;
	root = (bitree_t)malloc(sizeof(bitree));
	if(root == NULL)
	{
		DEBUG_CUSTOMERR("malloc error");
		return NULL;
	}
	root->data = ch;//填充数据
	root->lchild = bitree_create();//递归生成左子树,这里左右孩子是struct node*类型，也是bitree_t类型，所以可以作为bitree_create的返回值
	root->rchild = bitree_create();//递归生成右子树
	return root;
}
```

*参考文档：*
*[linux 标准IO缓冲机制探究][6]*
*[Linux中带缓冲IO和不带缓冲IO的详细说明][7]*
*[深究标准IO的缓存][8]*
*[scanf函数与输入缓冲区][11]*

## 函数介绍
标准IO函数的介绍主要是理解各个函数使用的特点，以便合理的选择。详细使用方法见man手册。

### 打开流fopen/关闭流fclose
**打开流**

- 相关函数fopen/freopen/fdopen。fopen最常用，freopen常用于将指定文件打开为预定义的流。fdopen常用于关联由管道、网络通信返回的文件描述符对应的文件。
- mode参数各种选项不同，对应不同的方式打开流，在实际应用中根据不同的情况选择。详情可参考man fopen。代码详见[gist][14]。
	- r 打开只读文件，文件必须存在，光标在文件开头。读从文件开头开始。
	- r+ 打开可读写文件，文件必须存在，光标在文件开头。读写均从文件开头开始。**因此如果文件有内容，写操作会覆盖部分内容。**
	- w 打开只写文件，文件不存在则创建，文件存在则清空内容，光标在文件开头。写从文件开头开始。
	- w+ 打开可读写文件，文件不存在则创建，文件存在则清空内容，光标在文件开头。读写均从文件开头开始。
	- a 打开只写文件，文件不存在则创建，文件存在则写入的内容在文件尾，光标在文件结尾。
	- a+ 打开可读写文件，文件不存在则创建。文件存在则**读从文件开始读，写从文件结尾写。**
- fopen函数使用w或者a创建文件时，不能说明文件的访问权限位，系统有默认值0666，文件的最终访问权限为0666 & ～umask。使用umask命令查看当前系统umask值，使用umask xxx命令设置。
- 除去标准输入、标准输出、标准出错三个流，最多可以打开1021个文件流。 

*参考文档：*
*[fopen中r+和w+的区别 ][9]*
*[fopen 的参数 w+, r+, a+][10]*

**关闭流**

- fclose通常和fopen配对使用。
- 不要多次使用fclose，一次即可。
- 在使用fclose时，将刷新缓冲区中输出的内容，丢弃输入的内容，释放自动分配的缓冲区。
- 如果程序正常结束，所有带未写缓冲数据的标准IO流将被刷新，打开的标准IO流将被关闭。

### 读写流
#### 每次一个字符的IO
- 输入：getc/fgetc/getchar
- 输出：putc/fputc/putchar
- getc的实现是函数宏，而fgetc实现是函数。getchar相当于getc(stdin)，getchar实现也是函数宏。
- 输入的三个函数到达文件结尾或者出错均返回EOF，需要使用ferror和feof区分。其返回值是int类型，因为包括0-255,-1。
- putc的实现为函数宏，而fputc实现是函数。putchar相当于putc(c,stdout)，putchar实现也是函数宏。
- 不推荐使用getc。

#### 每次一行的IO
- 输入：fgets/gets
- 输出：fputs/puts
- 输入函数成功返回buf,失败或到达文件尾返回NULL。
- fgets从指定流读入。fgets一直读到'\n'结束，但是不能超过n-1个字符，因为自动加'\0'。如果字符长度超过n，下一次调用fgets会继续读该行。fgets会将'\n'包括在内，所以实践中常需要将最后一个字符改变一下。字符长度包括'\n'字符在内。
- gets从标准输入读入，不包括'\n',不推荐使用gets，因为没有指定长度，那么可能超过buf缓存的长度，造成越界，产生不可预料的后果。
- 输出的两个函数是输出第一个'\0'前的内容。
- fputs将第一个'\0'前的内容输出到指定流。不一定每次输出一行，因为不要求在'\0'前面一定是'\n'。这是通常的情况，也有例外。
- puts将第一个'\0'前的内容输出到标准输出，输出后会自带换行符。
虽然puts不像gets一样不安全，但是也避免使用，以免需要记住它在最后又加上了'\n'。而使用fgets/fputs，在每行终止处需要自己加上'\n'。

#### 二进制IO
- 输入：fread
- 输出：fwrite
- fread/fwrite常用于读写**结构体数组**到文件。以对象为单位读写，成功返回读写的对象数。
- 使用fgetc/fputc/fputs/fgets等都有一些限制，比如效率低，遇到'\0'停止等。而fread/fwrite可以读写整个结构。
- size参数为一个对象的大小，nmemb参数是要读写的对象数，注意不能超过可读写的最大范围。

#### 格式化IO
- 输入：scanf/fscanf/sscanf
- 输出：printf/fprintf/dprintf/sprintf/snprintf
- 输入函数scanf从标准输入读入，fscanf从指定流读入，sscanf从buf读入。scanf成功返回输入变量的个数。
- 输出函数printf将格式化数据输出到标准输出，fprintf将格式化数据输出到指定流，dprintf写至指定文件描述符，sprintf将格式化字符送入数组buf，snprintf是限制了buf长度的输出。
- scanf可能产生垃圾字符，使用getchar清除。
- sprintf和snprintf都会自动在结尾添加'\0'，有多种用途，详见[sprintf用法详解][12]。

### 流结束判断和错误判断
- feof函数用于判断是否达到文件结尾。EOF文件结束标志位，其是值为-1的常量。
- ferror函数用于判断流是否出错。
- clearerr函数清除出错标志位，清除文件结束标志位。

*注：出错时，可以进行错误打印，函数有strerror打印出错原因。perror打印出错原因和用户信息，自带换行。还可以自己定义出错打印信息。其中错误码errno在errno.h中定义，全局可见。*

### 定位流
- 方式一：fseek/ftell/rewind
- 方式二：fgetpos/fsetpos
- fseek/ftell是假定文件位置存放在一个长整型中。ftell用于获取文件位置。fseek用于设定光标位置。rewind相当于fseek(stream,0L,SEEK_SET)。
- fgetpos/fsetpos是将光标位置记录在fpos_t类型的对象中。fsetpos相当于fseek的whence为SEEK_SET。
- 文件大小可以使用fseek求得。

# 文件IO
## 基本概念
### 概述
- 文件IO是不带缓冲的IO。不带缓冲是指每个read和write都调用内核中的一个系统调用。
- 不带缓冲的IO操作不是ANSI C的组成部分，但是是POSIX和XPG3的组成部分。
- 通常可用的文件IO函数主要有五个：open/close/read/write/lseek。
- 在直接操作设备文件时多用文件IO，而不是普通文件。

### 文件描述符
- **文件IO是围绕文件描述符来操作的**。所有打开的文件都由文件描述符引用。
- 文件描述符是一个非负整数。当打开一个现存文件或者创建一个新的文件，内核向进程返回一个文件描述符。此后的read,write操作都使用该文件描述符。
- 一个系统能够打开的文件个数是有限的，即文件描述符有一个上限值。运行ulimit -a可以看到open file上限值为1024。
- POSIX规定幻数0、1、2应被换成符号常数STDIN_FILENO、STDOUT_FILENO、STDERR_FILENO，它们定义在unistd.h中。一个进程启动时，会打开这3个文件。
- 基于文件描述符的IO操作是实现某些IO操作的唯一途径，比如中低级文件操作函数、多路IO、TCP/IP套结字编程接口等。

## 函数介绍
### 打开open/关闭close
- open函数返回的文件描述符是最小的未被使用的文件描述符。
- open函数用于创建时，会使用第三个参数，指明文件的访问权限mode。
- open函数第二个参数oflag指明文件的各选项，常用的有O_RDONLY、O_WRONLY、O_RDWR、O_APPEND、O_CREAT、O_EXCL、O_NONBLOCK、O_TRUNC。多个常量使用或运算构成，前三个常量互斥。
- open可以打开设备文件，但是不能创建设备文件，设备文件必须使用mknod创建。
- close用来关闭一个打开的文件。当进程终止时，也会由内核自动关闭。

使用示例：
```
int main(int argc, const char *argv[])
{
	int fd;
	fd = open("test1",O_RDWR | O_CREAT | O_EXCL,0777);//O_CREAT如果文件不存在则创建，并用第三个参数设置权限。O_EXCL测试文件是否存在
	if(fd == -1)
	{
		if(errno == EEXIST) //分析一下错误原因，如果存在直接打开并清空内容
		{
			printf("file already exist\n");
			if((fd = open("test1",O_RDWR | O_TRUNC)) < 0)//O_TRUNC打开文件时先删除文件原有数据
			{
				perror("fail to open");
				return -1;
			}
		}
		else
		{
			perror("fail to open");
			return -1;
		}
	}
	close(fd);
	return 0;
}
```

### 读read/写write
- read从一个已打开的可读文件中读取数据。
- read一般要根据返回值进行判断。参数nbytes是期望读的字节数。成功返回实际读取的字节数，失败返回-1,达到文件末尾返回0。
- 读操作是从文件当前位移量处开始，成功返回前，位移量增加实际读取字节数。
- write向一个已经打开的可写文件中写入数据。
- write调用成功返回已写的字节数，失败返回-1。参数是期望写入的字节数，因此，需要循环将全部待写的数据写入文件。
- write出错的原因可能是磁盘已满或者超过了一个给定进程文件长度限制。
- 写操作从文件当前偏移量处开始。如果打开时指定了O_APPEND则光标在结尾处。成功返回前，位移量增加实际写入的字节数。

### 定位文件lseek
- 每个打开的文件都有一个当前文件偏移量，用以度量从文件开始处计算的字节数。
-  通常读写都是从当前文件位移量处开始。如果打开时指定了O_APPEND参数，则每次从文件结尾开始写。一般情况，打开一个文件，偏移量为0。
- lseek定位文件，成功返回新的文件位移量，失败返回-1。可以用来测文件大小。
- lseek中如果whence是SEEK_CUR、SEEK_END，则offset可正可负。
- lseek只对常规文件有效，对于socket、管道、FIFO等进行lseek操作失败。
- lseek仅将当前文件的位移量记录在内核中，它并不引起任何IO操作。该偏移量用于下一次的读或写。
- 关于空洞：文件位移量可以设置大于文件当前长度，然后对文件的写操作会延长文件，从而形成空洞。位于文件中没有被写过的字节都将被读为0。空洞不会在磁盘上占有存储区。在多线程中有用，具体可另做讨论。

# 标准IO和文件IO的区别
**标准IO**
- 由库函数提供的函数接口。
- 缓冲IO，高级磁盘IO，遵循ANSI C标准，头文件为&lt;stdio.h&gt;。
- 函数围绕流展开。
- 通常只用来访问普通文件。
- 优点：减少对硬件的频繁操作，有利于保护硬件，适应性更强。
- 缺点：缓存区的数据可能丢失，开发人员写的库源码有问题，影响程序员的操作。

**文件IO**
- 由系统调用提供的函数接口。
- 非缓冲IO，低级磁盘IO，遵循POSIX标准，头文件为&lt;unistd.h&gt;。
- 函数围绕文件描述符展开。
- 可以访问不同类型的文件，如普通文件，设备文件，管道文件，套接字文件等。
- 优点：数据实时写入硬件，代码稳定。
- 缺点：频繁操作硬件，不利于保护硬件，增加系统开销。

*注意：文件IO使用的函数和标准IO是类似的，只是函数原型有所差异，可以对比记忆。*

*参考文档：*
*[标准IO与文件IO 的区别][13]*

# 总结
1. 以何种方式打开文件，根据实际情况而定，主要考虑是否可读，是否可写，读写从什么位置开始。
2. fopen/fclose，open/close一定配对使用，如果未关闭，可能导致错误。
3. 读和写在一起操作时，需要注意光标的位置，必要时用fseek或者lseek调整光标位置。
4. 使用fgets后，需使用feof判断是否到达文件结尾。
5. 使用fgets要注意可能需要将最后一个'\n'字符转换为'\0'。
6. 使用fputs需要自己添加'\n'，才可以写入'\n'。
7. 区别fwrite、fgets、fprintf，根据其不同的特点选用。
8. 使用sprintf/snprintf会自动加上'\0'，注意buf长度。而strncpy却不能保证有'\0'。
9. 对流的写操作，注意使用fflush刷新流。
10. 实践中，对普通文件的读写通常用标准IO，对设备文件读写用文件IO，比如串口、GPIO、IIC、SPI都有使用open/close,read/write函数。
11. 除了本篇所述的函数外，fcntl和ioctl函数在实践中也经常用到，在进程相关部分进行总结。例如IIC使用ioctl函数设置主从。fcntl设置文件状态使其非阻塞读写，设置异步IO所有权注册信号等。
12. 除了对普通文件的IO进行打开、读、写操作外，还可以获得文件信息，修改文件属性，涉及函数stat,chmod,umask,chown等，详情参考《UNIX环境高级编程》第4章文件和目录，其中还包括了对目录的操作，涉及opendir,readdir,chdir等函数。此处省略。这些函数通常有对应的shell命令，可通过熟知的shell命令了解对应函数的用法。
13. 在实践中曾经遇到读取字符串最后一个字符为'\n',未处理'\n'，导致拼接的shell命令无法识别，将其转换为'\0'解决问题，详情参考[gist][15]。

# 个人观点
1. 关于标准IO和文件IO的使用，在实践中是十分常用的，只需熟悉各个函数的特点，根据实际情况选用，不需记忆，多查看man手册。
2. 读和写是两种基本的操作。很多情况下要抓住这个本质。比如通信中的发送和接收，比如查看就是读操作，控制就是写操作。比如GPIO中的配置通常是使用write函数完成写操作。

[1]: http://www.xuebuyuan.com/556805.html
[2]: http://www.hqyj.com/news/emb167.htm
[3]: http://blog.csdn.net/lf_2016/article/details/54587020
[4]: https://www.cnblogs.com/yudao/p/4369982.html
[5]: https://www.cnblogs.com/happyliuyi/p/5126876.html
[6]: http://blog.chinaunix.net/uid-26833883-id-3198114.html
[7]: http://blog.csdn.net/scottly1/article/details/24186719
[8]: https://www.cnblogs.com/orlion/p/6258691.html
[9]: http://blog.csdn.net/u011412619/article/details/42143943
[10]: http://blog.csdn.net/flyfy1/article/details/4763347
[11]: http://blog.csdn.net/veniversum/article/details/52901619
[12]:https://www.cnblogs.com/lidabo/archive/2012/08/24/2654344.html
[13]: http://blog.csdn.net/big_bit/article/details/51804391
[14]: https://gist.github.com/youxiaobo/73a42523b8f702495ee838ab889df9be
[15]: https://gist.github.com/youxiaobo/8a8fcdc89ffd219f4c64a28f148b25ec